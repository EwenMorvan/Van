
C:\Users\Ewen\AppData\Local\arduino\sketches\13B07EAA6C925481F9FE8FE7E3C89171/ATtiny402_HTCO2.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../../crt1/gcrt1.S:63
   0:	1a c0       	rjmp	.+52     	; 0x36 <__ctors_end>
../../../../../crt1/gcrt1.S:67
   2:	3f c0       	rjmp	.+126    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:68
   4:	3e c0       	rjmp	.+124    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:69
   6:	3d c0       	rjmp	.+122    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:70
   8:	3c c0       	rjmp	.+120    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:71
   a:	3b c0       	rjmp	.+118    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:72
   c:	3a c0       	rjmp	.+116    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:73
   e:	39 c0       	rjmp	.+114    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:74
  10:	38 c0       	rjmp	.+112    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:75
  12:	91 c2       	rjmp	.+1314   	; 0x536 <__vector_9>
../../../../../crt1/gcrt1.S:76
  14:	36 c0       	rjmp	.+108    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:77
  16:	35 c0       	rjmp	.+106    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:78
  18:	34 c0       	rjmp	.+104    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:79
  1a:	33 c0       	rjmp	.+102    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:80
  1c:	32 c0       	rjmp	.+100    	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:81
  1e:	31 c0       	rjmp	.+98     	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:82
  20:	30 c0       	rjmp	.+96     	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:83
  22:	2f c0       	rjmp	.+94     	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:84
  24:	2e c0       	rjmp	.+92     	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:85
  26:	3a c3       	rjmp	.+1652   	; 0x69c <__vector_19>
../../../../../crt1/gcrt1.S:86
  28:	2c c0       	rjmp	.+88     	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:87
  2a:	2b c0       	rjmp	.+86     	; 0x82 <__bad_interrupt>
../../../../../crt1/gcrt1.S:88
  2c:	b9 c2       	rjmp	.+1394   	; 0x5a0 <__vector_22>
../../../../../crt1/gcrt1.S:89
  2e:	b2 c2       	rjmp	.+1380   	; 0x594 <__vector_23>
../../../../../crt1/gcrt1.S:90
  30:	bd c2       	rjmp	.+1402   	; 0x5ac <__vector_24>
../../../../../crt1/gcrt1.S:91
  32:	27 c0       	rjmp	.+78     	; 0x82 <__bad_interrupt>

00000034 <__ctors_start>:
__trampolines_start():
  34:	f4 03       	fmuls	r23, r20

00000036 <__ctors_end>:
__dtors_end():
../../../../../crt1/gcrt1.S:230
  36:	11 24       	eor	r1, r1
../../../../../crt1/gcrt1.S:231
  38:	1f be       	out	0x3f, r1	; 63
../../../../../crt1/gcrt1.S:232
  3a:	cf ef       	ldi	r28, 0xFF	; 255
../../../../../crt1/gcrt1.S:234
  3c:	cd bf       	out	0x3d, r28	; 61
../../../../../crt1/gcrt1.S:236
  3e:	df e3       	ldi	r29, 0x3F	; 63
../../../../../crt1/gcrt1.S:237
  40:	de bf       	out	0x3e, r29	; 62

00000042 <_initThreeStuff()>:
init_reset_flags():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/main.cpp:104

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  42:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <vtable for TwoWire+0x7f738a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/main.cpp:105
    RSTCTRL.RSTFR = flags;
  46:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <vtable for TwoWire+0x7f738a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/main.cpp:106
    if (flags == 0) {
  4a:	81 11       	cpse	r24, r1
  4c:	05 c0       	rjmp	.+10     	; 0x58 <_initThreeStuff()+0x16>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/main.cpp:107
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  4e:	98 ed       	ldi	r25, 0xD8	; 216
  50:	21 e0       	ldi	r18, 0x01	; 1
  52:	94 bf       	out	0x34, r25	; 52
  54:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <vtable for TwoWire+0x7f738b>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/main.cpp:109
    }
    GPIOR0 = flags;
  58:	8c bb       	out	0x1c, r24	; 28

0000005a <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  5a:	2f e3       	ldi	r18, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  5c:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  5e:	bf e3       	ldi	r27, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  60:	01 c0       	rjmp	.+2      	; 0x64 <.do_clear_bss_start>

00000062 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  62:	1d 92       	st	X+, r1

00000064 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  64:	a3 37       	cpi	r26, 0x73	; 115
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  66:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  68:	e1 f7       	brne	.-8      	; 0x62 <.do_clear_bss_loop>

0000006a <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  6a:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  6c:	cb e1       	ldi	r28, 0x1B	; 27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  6e:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  70:	03 c0       	rjmp	.+6      	; 0x78 <__do_global_ctors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  72:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  74:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  76:	01 d6       	rcall	.+3074   	; 0xc7a <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  78:	ca 31       	cpi	r28, 0x1A	; 26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  7a:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  7c:	d1 f7       	brne	.-12     	; 0x72 <__do_global_ctors+0x8>
../../../../../crt1/gcrt1.S:314
  7e:	df d3       	rcall	.+1982   	; 0x83e <main>
../../../../../crt1/gcrt1.S:315
  80:	02 c6       	rjmp	.+3076   	; 0xc86 <_exit>

00000082 <__bad_interrupt>:
__vector_1():
../../../../../crt1/gcrt1.S:209
  82:	be cf       	rjmp	.-132    	; 0x0 <__vectors>

00000084 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]>:
masterTransmit():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:831
 *@param      uint8_t/bool sendStop - if the transaction should be terminated with a STOP condition
 *
 *@return     uint8_t
 *@retval     errors (see endTransmission)
 */
uint8_t TwoWire::masterTransmit(auto *length, uint8_t *buffer, uint8_t addr, uint8_t sendStop) {
  84:	0f 93       	push	r16
  86:	1f 93       	push	r17
  88:	cf 93       	push	r28
  8a:	df 93       	push	r29
  8c:	ec 01       	movw	r28, r24
  8e:	8b 01       	movw	r16, r22
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:832
  TWI_t* module = _module;
  90:	e0 91 46 3f 	lds	r30, 0x3F46	; 0x803f46 <Wire+0x8>
  94:	f0 91 47 3f 	lds	r31, 0x3F47	; 0x803f47 <Wire+0x9>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:844
  auto dataToWrite = *length;
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = (F_CPU/1000);
  #endif

  if ((module->MCTRLA & TWI_ENABLE_bm) == 0x00) {  // If the module is disabled, abort
  98:	83 81       	ldd	r24, Z+3	; 0x03
  9a:	80 fd       	sbrc	r24, 0
  9c:	06 c0       	rjmp	.+12     	; 0xaa <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x26>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:845
    return TWI_ERR_UNINIT;
  9e:	80 e1       	ldi	r24, 0x10	; 16
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:913
  *length -= dataToWrite;
  if ((sendStop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
    module->MCTRLB = TWI_MCMD_STOP_gc;                        // Send STOP
  }
  return TWI_GET_ERROR;
}
  a0:	df 91       	pop	r29
  a2:	cf 91       	pop	r28
  a4:	1f 91       	pop	r17
  a6:	0f 91       	pop	r16
  a8:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:839

  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t stat = 0;
  auto dataToWrite = *length;
  aa:	98 81       	ld	r25, Y
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:841
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = (F_CPU/1000);
  ac:	a0 e2       	ldi	r26, 0x20	; 32
  ae:	be e4       	ldi	r27, 0x4E	; 78
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:838
  __asm__ __volatile__("\n\t" : "+z"(module));

  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t stat = 0;
  b0:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:875
      return TWI_ERR_BUS_ARB;                 // leave TX loop, don't update bytes to read and don't try to send stop
    }

    if (currentSM != TWI_BUSSTATE_BUSY_gc) {  // Undefined was excluded, so make sure it's IDLE or OWNER
      if (stat == 0x00) {                     // At the start, we send the ADDR
        module->MADDR = ADD_WRITE_BIT(addr);      // clear bit 0
  b2:	4e 7f       	andi	r20, 0xFE	; 254
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:849
  if ((module->MCTRLA & TWI_ENABLE_bm) == 0x00) {  // If the module is disabled, abort
    return TWI_ERR_UNINIT;
  }

  while (true) {
    currentStatus = module->MSTATUS;
  b4:	55 81       	ldd	r21, Z+5	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:850
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
  b6:	75 2f       	mov	r23, r21
  b8:	73 70       	andi	r23, 0x03	; 3
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:852

    if (currentSM == TWI_BUSSTATE_UNKNOWN_gc) { // If the bus was not initialized
  ba:	89 f3       	breq	.-30     	; 0x9e <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x1a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:857
      return TWI_ERR_UNINIT;                    // abort
    }

    #if defined(TWI_TIMEOUT_ENABLE)
      if (--timeout == 0) {
  bc:	11 97       	sbiw	r26, 0x01	; 1
  be:	89 f4       	brne	.+34     	; 0xe2 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x5e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:859
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
  c0:	85 e0       	ldi	r24, 0x05	; 5
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:858
      return TWI_ERR_UNINIT;                    // abort
    }

    #if defined(TWI_TIMEOUT_ENABLE)
      if (--timeout == 0) {
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
  c2:	72 30       	cpi	r23, 0x02	; 2
  c4:	21 f0       	breq	.+8      	; 0xce <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x4a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:863
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
          TWI_SET_ERROR(TWI_ERR_PULLUP);
        } else {
          TWI_SET_ERROR(TWI_ERR_UNDEFINED);
  c6:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:860

    #if defined(TWI_TIMEOUT_ENABLE)
      if (--timeout == 0) {
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
  c8:	71 30       	cpi	r23, 0x01	; 1
  ca:	09 f4       	brne	.+2      	; 0xce <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x4a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:861
          TWI_SET_ERROR(TWI_ERR_PULLUP);
  cc:	81 e1       	ldi	r24, 0x11	; 17
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:908
        }
      } /* dataWritten == 0 */
    } /* currentSM != TWI_BUSSTATE_BUSY_gc */
  } /* while */

  *length -= dataToWrite;
  ce:	38 81       	ld	r19, Y
  d0:	39 1b       	sub	r19, r25
  d2:	38 83       	st	Y, r19
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:909
  if ((sendStop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
  d4:	21 11       	cpse	r18, r1
  d6:	02 c0       	rjmp	.+4      	; 0xdc <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x58>
  d8:	88 23       	and	r24, r24
  da:	11 f3       	breq	.-60     	; 0xa0 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x1c>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:910
    module->MCTRLB = TWI_MCMD_STOP_gc;                        // Send STOP
  dc:	93 e0       	ldi	r25, 0x03	; 3
  de:	94 83       	std	Z+4, r25	; 0x04
  e0:	df cf       	rjmp	.-66     	; 0xa0 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x1c>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:869
        }
        break;
      }
    #endif

    if (currentStatus & TWI_ARBLOST_bm) {     // Check for Bus error
  e2:	53 fd       	sbrc	r21, 3
  e4:	20 c0       	rjmp	.+64     	; 0x126 <__DATA_REGION_LENGTH__+0x26>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:873
      return TWI_ERR_BUS_ARB;                 // leave TX loop, don't update bytes to read and don't try to send stop
    }

    if (currentSM != TWI_BUSSTATE_BUSY_gc) {  // Undefined was excluded, so make sure it's IDLE or OWNER
  e6:	73 30       	cpi	r23, 0x03	; 3
  e8:	29 f3       	breq	.-54     	; 0xb4 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x30>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:874
      if (stat == 0x00) {                     // At the start, we send the ADDR
  ea:	31 11       	cpse	r19, r1
  ec:	05 c0       	rjmp	.+10     	; 0xf8 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x74>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:875
        module->MADDR = ADD_WRITE_BIT(addr);      // clear bit 0
  ee:	47 83       	std	Z+7, r20	; 0x07
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:878
        stat |= 0x01;                             // skip this if we're done
        #if defined (TWI_TIMEOUT_ENABLE)
          timeout = (F_CPU/1000);                 // reset timeout
  f0:	a0 e2       	ldi	r26, 0x20	; 32
  f2:	be e4       	ldi	r27, 0x4E	; 78
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:876
    }

    if (currentSM != TWI_BUSSTATE_BUSY_gc) {  // Undefined was excluded, so make sure it's IDLE or OWNER
      if (stat == 0x00) {                     // At the start, we send the ADDR
        module->MADDR = ADD_WRITE_BIT(addr);      // clear bit 0
        stat |= 0x01;                             // skip this if we're done
  f4:	31 e0       	ldi	r19, 0x01	; 1
  f6:	de cf       	rjmp	.-68     	; 0xb4 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x30>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:881
        #if defined (TWI_TIMEOUT_ENABLE)
          timeout = (F_CPU/1000);                 // reset timeout
        #endif
      } else {
        if (currentStatus & TWI_WIF_bm) {     // ADDR was sent, check for completed write
  f8:	56 ff       	sbrs	r21, 6
  fa:	dc cf       	rjmp	.-72     	; 0xb4 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x30>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:882
          if (currentStatus & TWI_RXACK_bm) {   // got a NACK, see how much was written
  fc:	54 ff       	sbrs	r21, 4
  fe:	08 c0       	rjmp	.+16     	; 0x110 <__DATA_REGION_LENGTH__+0x10>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:887
            if (stat & 0x02) {                  // bit 1 set, data was already sent
              if (dataToWrite != 0)               // the client may send an ACK at the end. If we
                TWI_SET_ERROR(TWI_ERR_ACK_DAT);   // transferred everything, we can ignore the NACK
            } else {                              // otherwise, no data sent, ADDR NACK
              TWI_SET_ERROR(TWI_ERR_ACK_ADR);
 100:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:883
          timeout = (F_CPU/1000);                 // reset timeout
        #endif
      } else {
        if (currentStatus & TWI_WIF_bm) {     // ADDR was sent, check for completed write
          if (currentStatus & TWI_RXACK_bm) {   // got a NACK, see how much was written
            if (stat & 0x02) {                  // bit 1 set, data was already sent
 102:	31 ff       	sbrs	r19, 1
 104:	e4 cf       	rjmp	.-56     	; 0xce <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x4a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:885
              if (dataToWrite != 0)               // the client may send an ACK at the end. If we
                TWI_SET_ERROR(TWI_ERR_ACK_DAT);   // transferred everything, we can ignore the NACK
 106:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:884
        #endif
      } else {
        if (currentStatus & TWI_WIF_bm) {     // ADDR was sent, check for completed write
          if (currentStatus & TWI_RXACK_bm) {   // got a NACK, see how much was written
            if (stat & 0x02) {                  // bit 1 set, data was already sent
              if (dataToWrite != 0)               // the client may send an ACK at the end. If we
 108:	91 11       	cpse	r25, r1
 10a:	e1 cf       	rjmp	.-62     	; 0xce <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x4a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:835
 */
uint8_t TwoWire::masterTransmit(auto *length, uint8_t *buffer, uint8_t addr, uint8_t sendStop) {
  TWI_t* module = _module;
  __asm__ __volatile__("\n\t" : "+z"(module));

  TWI_INIT_ERROR;
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	df cf       	rjmp	.-66     	; 0xce <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x4a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:891
            } else {                              // otherwise, no data sent, ADDR NACK
              TWI_SET_ERROR(TWI_ERR_ACK_ADR);
            }
            break;
          } else {                              // No NACK on write
            if (dataToWrite != 0) {             // check if there is data to be written
 110:	99 23       	and	r25, r25
 112:	e1 f3       	breq	.-8      	; 0x10c <__DATA_REGION_LENGTH__+0xc>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:892
              module->MDATA = *buffer;          // Writing to the register to send data
 114:	d8 01       	movw	r26, r16
 116:	8d 91       	ld	r24, X+
 118:	8d 01       	movw	r16, r26
 11a:	80 87       	std	Z+8, r24	; 0x08
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:894
              buffer++;
              dataToWrite--;
 11c:	91 50       	subi	r25, 0x01	; 1
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:895
              stat |= 0x02;                     // remember that we've sent data
 11e:	32 60       	ori	r19, 0x02	; 2
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:897
              #if defined (TWI_TIMEOUT_ENABLE)
                timeout = (F_CPU/1000);                   // reset timeout
 120:	a0 e2       	ldi	r26, 0x20	; 32
 122:	be e4       	ldi	r27, 0x4E	; 78
 124:	c7 cf       	rjmp	.-114    	; 0xb4 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x30>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:870
        break;
      }
    #endif

    if (currentStatus & TWI_ARBLOST_bm) {     // Check for Bus error
      return TWI_ERR_BUS_ARB;                 // leave TX loop, don't update bytes to read and don't try to send stop
 126:	82 e1       	ldi	r24, 0x12	; 18
 128:	bb cf       	rjmp	.-138    	; 0xa0 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]+0x1c>

0000012a <delay.part.0>:
delay.part.0():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:243
        start += 1000;
      }
    }
  }
#else
  void delay(uint32_t ms) {
 12a:	0f 93       	push	r16
 12c:	1f 93       	push	r17
 12e:	ab 01       	movw	r20, r22
 130:	bc 01       	movw	r22, r24
millis():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:167
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
 132:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:168
    cli();
 134:	f8 94       	cli
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:182
        if (!(rtccount & 0x8000)) m += 64000;
      }
      SREG = oldSREG;
      m += rtccount - (rtccount >> 5) + (rtccount >> 7);
    #else
      m = timingStruct.timer_millis;
 136:	00 91 05 3f 	lds	r16, 0x3F05	; 0x803f05 <timingStruct+0x4>
 13a:	10 91 06 3f 	lds	r17, 0x3F06	; 0x803f06 <timingStruct+0x5>
 13e:	20 91 07 3f 	lds	r18, 0x3F07	; 0x803f07 <timingStruct+0x6>
 142:	30 91 08 3f 	lds	r19, 0x3F08	; 0x803f08 <timingStruct+0x7>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:183
      SREG = oldSREG;
 146:	8f bf       	out	0x3f, r24	; 63
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:167
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
 148:	ef b7       	in	r30, 0x3f	; 63
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:168
    cli();
 14a:	f8 94       	cli
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:182
        if (!(rtccount & 0x8000)) m += 64000;
      }
      SREG = oldSREG;
      m += rtccount - (rtccount >> 5) + (rtccount >> 7);
    #else
      m = timingStruct.timer_millis;
 14c:	80 91 05 3f 	lds	r24, 0x3F05	; 0x803f05 <timingStruct+0x4>
 150:	90 91 06 3f 	lds	r25, 0x3F06	; 0x803f06 <timingStruct+0x5>
 154:	a0 91 07 3f 	lds	r26, 0x3F07	; 0x803f07 <timingStruct+0x6>
 158:	b0 91 08 3f 	lds	r27, 0x3F08	; 0x803f08 <timingStruct+0x7>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:183
      SREG = oldSREG;
 15c:	ef bf       	out	0x3f, r30	; 63
delay.part.0():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:252
      while(ms--) {
        _delay_ms(1);
      }
    } else {
      uint32_t start = millis();
      while (millis() - start < ms);
 15e:	80 1b       	sub	r24, r16
 160:	91 0b       	sbc	r25, r17
 162:	a2 0b       	sbc	r26, r18
 164:	b3 0b       	sbc	r27, r19
 166:	84 17       	cp	r24, r20
 168:	95 07       	cpc	r25, r21
 16a:	a6 07       	cpc	r26, r22
 16c:	b7 07       	cpc	r27, r23
 16e:	60 f3       	brcs	.-40     	; 0x148 <delay.part.0+0x1e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:254
    }
  }
 170:	1f 91       	pop	r17
 172:	0f 91       	pop	r16
 174:	08 95       	ret

00000176 <TwoWire::available()>:
available():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:990
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
 176:	fc 01       	movw	r30, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:997
    if (_bools._toggleStreamFn == 0x01) {
      return (_bytesToReadWriteS - _bytesReadWrittenS);
    }
  #endif

  return (_bytesToReadWrite - _bytesReadWritten);
 178:	82 89       	ldd	r24, Z+18	; 0x12
 17a:	93 89       	ldd	r25, Z+19	; 0x13
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:998
}
 17c:	89 1b       	sub	r24, r25
 17e:	99 0b       	sbc	r25, r25
 180:	08 95       	ret

00000182 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
 182:	af 92       	push	r10
 184:	bf 92       	push	r11
 186:	cf 92       	push	r12
 188:	df 92       	push	r13
 18a:	ef 92       	push	r14
 18c:	ff 92       	push	r15
 18e:	0f 93       	push	r16
 190:	1f 93       	push	r17
 192:	cf 93       	push	r28
 194:	df 93       	push	r29
 196:	6c 01       	movw	r12, r24
 198:	7b 01       	movw	r14, r22
 19a:	8b 01       	movw	r16, r22
 19c:	04 0f       	add	r16, r20
 19e:	15 1f       	adc	r17, r21
 1a0:	eb 01       	movw	r28, r22
 1a2:	5e 01       	movw	r10, r28
 1a4:	ae 18       	sub	r10, r14
 1a6:	bf 08       	sbc	r11, r15
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
 1a8:	c0 17       	cp	r28, r16
 1aa:	d1 07       	cpc	r29, r17
 1ac:	59 f0       	breq	.+22     	; 0x1c4 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:32
    if (write(*buffer++)) {
 1ae:	69 91       	ld	r22, Y+
 1b0:	d6 01       	movw	r26, r12
 1b2:	ed 91       	ld	r30, X+
 1b4:	fc 91       	ld	r31, X
 1b6:	01 90       	ld	r0, Z+
 1b8:	f0 81       	ld	r31, Z
 1ba:	e0 2d       	mov	r30, r0
 1bc:	c6 01       	movw	r24, r12
 1be:	09 95       	icall
 1c0:	89 2b       	or	r24, r25
 1c2:	79 f7       	brne	.-34     	; 0x1a2 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
 1c4:	c5 01       	movw	r24, r10
 1c6:	df 91       	pop	r29
 1c8:	cf 91       	pop	r28
 1ca:	1f 91       	pop	r17
 1cc:	0f 91       	pop	r16
 1ce:	ff 90       	pop	r15
 1d0:	ef 90       	pop	r14
 1d2:	df 90       	pop	r13
 1d4:	cf 90       	pop	r12
 1d6:	bf 90       	pop	r11
 1d8:	af 90       	pop	r10
 1da:	08 95       	ret

000001dc <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:719
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
 1dc:	fc 01       	movw	r30, r24
 1de:	57 85       	ldd	r21, Z+15	; 0x0f
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:720
          tail = _tx_buffer_tail;
 1e0:	40 89       	ldd	r20, Z+16	; 0x10
 1e2:	25 2f       	mov	r18, r21
 1e4:	30 e0       	ldi	r19, 0x00	; 0
 1e6:	84 2f       	mov	r24, r20
 1e8:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:723
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 1ea:	82 1b       	sub	r24, r18
 1ec:	93 0b       	sbc	r25, r19
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:722

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
 1ee:	54 17       	cp	r21, r20
 1f0:	10 f0       	brcs	.+4      	; 0x1f6 <HardwareSerial::availableForWrite()+0x1a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:723
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
 1f2:	0f 96       	adiw	r24, 0x0f	; 15
 1f4:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:725
        }
        return tail - head - 1;
 1f6:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:726
      }
 1f8:	08 95       	ret

000001fa <HardwareSerial::read()>:
read():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:703
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
 1fa:	fc 01       	movw	r30, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:705
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
 1fc:	95 85       	ldd	r25, Z+13	; 0x0d
 1fe:	86 85       	ldd	r24, Z+14	; 0x0e
 200:	98 17       	cp	r25, r24
 202:	61 f0       	breq	.+24     	; 0x21c <HardwareSerial::read()+0x22>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:708
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
 204:	a6 85       	ldd	r26, Z+14	; 0x0e
 206:	ae 0f       	add	r26, r30
 208:	bf 2f       	mov	r27, r31
 20a:	b1 1d       	adc	r27, r1
 20c:	51 96       	adiw	r26, 0x11	; 17
 20e:	8c 91       	ld	r24, X
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:709
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
 210:	96 85       	ldd	r25, Z+14	; 0x0e
 212:	9f 5f       	subi	r25, 0xFF	; 255
 214:	9f 70       	andi	r25, 0x0F	; 15
 216:	96 87       	std	Z+14, r25	; 0x0e
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:710
        return c;
 218:	90 e0       	ldi	r25, 0x00	; 0
 21a:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:706
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
 21c:	8f ef       	ldi	r24, 0xFF	; 255
 21e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:712
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
 220:	08 95       	ret

00000222 <HardwareSerial::peek()>:
peek():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:695

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
 222:	fc 01       	movw	r30, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:696
      if (_rx_buffer_head == _rx_buffer_tail) {
 224:	95 85       	ldd	r25, Z+13	; 0x0d
 226:	86 85       	ldd	r24, Z+14	; 0x0e
 228:	98 17       	cp	r25, r24
 22a:	31 f0       	breq	.+12     	; 0x238 <HardwareSerial::peek()+0x16>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:699
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
 22c:	86 85       	ldd	r24, Z+14	; 0x0e
 22e:	e8 0f       	add	r30, r24
 230:	f1 1d       	adc	r31, r1
 232:	81 89       	ldd	r24, Z+17	; 0x11
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:697
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
 238:	8f ef       	ldi	r24, 0xFF	; 255
 23a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:701
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
 23c:	08 95       	ret

0000023e <HardwareSerial::available()>:
available():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:691
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module off sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
 23e:	fc 01       	movw	r30, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:692
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
 240:	95 85       	ldd	r25, Z+13	; 0x0d
 242:	26 85       	ldd	r18, Z+14	; 0x0e
 244:	89 2f       	mov	r24, r25
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	40 96       	adiw	r24, 0x10	; 16
 24a:	82 1b       	sub	r24, r18
 24c:	91 09       	sbc	r25, r1
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:693
    }
 24e:	8f 70       	andi	r24, 0x0F	; 15
 250:	99 27       	eor	r25, r25
 252:	08 95       	ret

00000254 <HardwareSerial::_poll_tx_data_empty()>:
_poll_tx_data_empty():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:423
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
 254:	dc 01       	movw	r26, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:424
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
 256:	0f b6       	in	r0, 0x3f	; 63
 258:	07 fe       	sbrs	r0, 7
 25a:	04 c0       	rjmp	.+8      	; 0x264 <HardwareSerial::_poll_tx_data_empty()+0x10>
 25c:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <vtable for TwoWire+0x7f745b>
 260:	88 23       	and	r24, r24
 262:	b1 f0       	breq	.+44     	; 0x290 <_poll_dre_done>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:441
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
 264:	18 96       	adiw	r26, 0x08	; 8
 266:	ed 91       	ld	r30, X+
 268:	fc 91       	ld	r31, X
 26a:	19 97       	sbiw	r26, 0x09	; 9
 26c:	84 81       	ldd	r24, Z+4	; 0x04
 26e:	85 ff       	sbrs	r24, 5
 270:	0f c0       	rjmp	.+30     	; 0x290 <_poll_dre_done>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:442
          if (_tx_buffer_head == _tx_buffer_tail) {
 272:	1f 96       	adiw	r26, 0x0f	; 15
 274:	9c 91       	ld	r25, X
 276:	1f 97       	sbiw	r26, 0x0f	; 15
 278:	50 96       	adiw	r26, 0x10	; 16
 27a:	8c 91       	ld	r24, X
 27c:	98 13       	cpse	r25, r24
 27e:	04 c0       	rjmp	.+8      	; 0x288 <HardwareSerial::_poll_tx_data_empty()+0x34>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:444
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
 280:	85 81       	ldd	r24, Z+5	; 0x05
 282:	8f 7d       	andi	r24, 0xDF	; 223
 284:	85 83       	std	Z+5, r24	; 0x05
 286:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:468
      #ifdef USART1
                    ::"z"((uint16_t)thisSerial)
      #else
                    ::"z"(&Serial0)
      #endif
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
 288:	eb e0       	ldi	r30, 0x0B	; 11
 28a:	ff e3       	ldi	r31, 0x3F	; 63
 28c:	e8 94       	clt
 28e:	9b c1       	rjmp	.+822    	; 0x5c6 <_poll_dre>

00000290 <_poll_dre_done>:
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:477
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
 290:	08 95       	ret

00000292 <HardwareSerial::write(unsigned char)>:
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:759
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
 292:	0f 93       	push	r16
 294:	1f 93       	push	r17
 296:	cf 93       	push	r28
 298:	df 93       	push	r29
 29a:	ec 01       	movw	r28, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:760
        _state |= 1; // Record that we have written to serial since it was begun.
 29c:	8c 85       	ldd	r24, Y+12	; 0x0c
 29e:	81 60       	ori	r24, 0x01	; 1
 2a0:	8c 87       	std	Y+12, r24	; 0x0c
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:765
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
 2a2:	9f 85       	ldd	r25, Y+15	; 0x0f
 2a4:	88 89       	ldd	r24, Y+16	; 0x10
 2a6:	98 13       	cpse	r25, r24
 2a8:	0b c0       	rjmp	.+22     	; 0x2c0 <HardwareSerial::write(unsigned char)+0x2e>
 2aa:	e8 85       	ldd	r30, Y+8	; 0x08
 2ac:	f9 85       	ldd	r31, Y+9	; 0x09
 2ae:	84 81       	ldd	r24, Z+4	; 0x04
 2b0:	85 ff       	sbrs	r24, 5
 2b2:	06 c0       	rjmp	.+12     	; 0x2c0 <HardwareSerial::write(unsigned char)+0x2e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:766
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
 2b4:	8c 85       	ldd	r24, Y+12	; 0x0c
 2b6:	81 fd       	sbrc	r24, 1
 2b8:	0d c0       	rjmp	.+26     	; 0x2d4 <HardwareSerial::write(unsigned char)+0x42>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:773
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
 2ba:	80 e4       	ldi	r24, 0x40	; 64
 2bc:	84 83       	std	Z+4, r24	; 0x04
 2be:	12 c0       	rjmp	.+36     	; 0x2e4 <HardwareSerial::write(unsigned char)+0x52>
 2c0:	06 2f       	mov	r16, r22
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:794
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
 2c2:	1f 85       	ldd	r17, Y+15	; 0x0f
 2c4:	1f 5f       	subi	r17, 0xFF	; 255
 2c6:	1f 70       	andi	r17, 0x0F	; 15
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:798

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
 2c8:	88 89       	ldd	r24, Y+16	; 0x10
 2ca:	81 13       	cpse	r24, r17
 2cc:	15 c0       	rjmp	.+42     	; 0x2f8 <HardwareSerial::write(unsigned char)+0x66>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:799
          _poll_tx_data_empty();
 2ce:	ce 01       	movw	r24, r28
 2d0:	c1 df       	rcall	.-126    	; 0x254 <HardwareSerial::_poll_tx_data_empty()>
 2d2:	fa cf       	rjmp	.-12     	; 0x2c8 <HardwareSerial::write(unsigned char)+0x36>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:767
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
 2d4:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:768
            ctrla &= ~USART_RXCIE_bm;
 2d6:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:769
            ctrla |=  USART_TXCIE_bm;
 2d8:	80 64       	ori	r24, 0x40	; 64
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:770
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
 2da:	90 e4       	ldi	r25, 0x40	; 64
 2dc:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:771
            (*_hwserial_module).CTRLA = ctrla;
 2de:	e8 85       	ldd	r30, Y+8	; 0x08
 2e0:	f9 85       	ldd	r31, Y+9	; 0x09
 2e2:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:776
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
 2e4:	e8 85       	ldd	r30, Y+8	; 0x08
 2e6:	f9 85       	ldd	r31, Y+9	; 0x09
 2e8:	62 83       	std	Z+2, r22	; 0x02
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:815
          // Enable "data register empty interrupt"

          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
 2ea:	81 e0       	ldi	r24, 0x01	; 1
 2ec:	90 e0       	ldi	r25, 0x00	; 0
 2ee:	df 91       	pop	r29
 2f0:	cf 91       	pop	r28
 2f2:	1f 91       	pop	r17
 2f4:	0f 91       	pop	r16
 2f6:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:801
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
 2f8:	ef 85       	ldd	r30, Y+15	; 0x0f
 2fa:	ec 0f       	add	r30, r28
 2fc:	fd 2f       	mov	r31, r29
 2fe:	f1 1d       	adc	r31, r1
 300:	01 a3       	std	Z+33, r16	; 0x21
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:802
        _tx_buffer_head = i;
 302:	1f 87       	std	Y+15, r17	; 0x0f
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:803
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
 304:	8c 85       	ldd	r24, Y+12	; 0x0c
 306:	e8 85       	ldd	r30, Y+8	; 0x08
 308:	f9 85       	ldd	r31, Y+9	; 0x09
 30a:	81 ff       	sbrs	r24, 1
 30c:	09 c0       	rjmp	.+18     	; 0x320 <HardwareSerial::write(unsigned char)+0x8e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:804
          uint8_t ctrla = (*_hwserial_module).CTRLA;
 30e:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:805
          ctrla &= ~USART_RXCIE_bm;
 310:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:806
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
 312:	80 66       	ori	r24, 0x60	; 96
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:807
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
 314:	90 e4       	ldi	r25, 0x40	; 64
 316:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:808
          (*_hwserial_module).CTRLA = ctrla;
 318:	e8 85       	ldd	r30, Y+8	; 0x08
 31a:	f9 85       	ldd	r31, Y+9	; 0x09
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:812
        } else {
          // Enable "data register empty interrupt"

          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
 31c:	85 83       	std	Z+5, r24	; 0x05
 31e:	e5 cf       	rjmp	.-54     	; 0x2ea <HardwareSerial::write(unsigned char)+0x58>
 320:	85 81       	ldd	r24, Z+5	; 0x05
 322:	80 62       	ori	r24, 0x20	; 32
 324:	fb cf       	rjmp	.-10     	; 0x31c <HardwareSerial::write(unsigned char)+0x8a>

00000326 <HardwareSerial::flush()>:
flush():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:728
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
 326:	cf 93       	push	r28
 328:	df 93       	push	r29
 32a:	ec 01       	movw	r28, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:732
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!(_state & 1)) {
 32c:	8c 85       	ldd	r24, Y+12	; 0x0c
 32e:	80 ff       	sbrs	r24, 0
 330:	0b c0       	rjmp	.+22     	; 0x348 <HardwareSerial::flush()+0x22>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:747
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
 332:	e8 85       	ldd	r30, Y+8	; 0x08
 334:	f9 85       	ldd	r31, Y+9	; 0x09
 336:	85 81       	ldd	r24, Z+5	; 0x05
 338:	85 fd       	sbrc	r24, 5
 33a:	03 c0       	rjmp	.+6      	; 0x342 <HardwareSerial::flush()+0x1c>
 33c:	84 81       	ldd	r24, Z+4	; 0x04
 33e:	86 fd       	sbrc	r24, 6
 340:	03 c0       	rjmp	.+6      	; 0x348 <HardwareSerial::flush()+0x22>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:752

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
 342:	ce 01       	movw	r24, r28
 344:	87 df       	rcall	.-242    	; 0x254 <HardwareSerial::_poll_tx_data_empty()>
 346:	f5 cf       	rjmp	.-22     	; 0x332 <HardwareSerial::flush()+0xc>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:756
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
 348:	df 91       	pop	r29
 34a:	cf 91       	pop	r28
 34c:	08 95       	ret

0000034e <TwoWire::flush()>:
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1115
 *
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_t* module = _module;
 34e:	dc 01       	movw	r26, r24
 350:	18 96       	adiw	r26, 0x08	; 8
 352:	ed 91       	ld	r30, X+
 354:	fc 91       	ld	r31, X
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1127
    module->SCTRLA  = 0x00;
    module->MCTRLA  = temp_MCTRLA;
    module->MSTATUS = 0x01;  // force TWI state machine into idle state
    module->SCTRLA  = temp_SCTRLA;
  #else
    module->MCTRLB |= TWI_FLUSH_bm;
 356:	84 81       	ldd	r24, Z+4	; 0x04
 358:	88 60       	ori	r24, 0x08	; 8
 35a:	84 83       	std	Z+4, r24	; 0x04
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1129
  #endif
}
 35c:	08 95       	ret

0000035e <TwoWire::peek()>:
peek():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1095
    } else
  #endif
  {
    rxHead   = &(_bytesToReadWrite);
    rxTail   = &(_bytesReadWritten);
    rxBuffer =   _hostBuffer;
 35e:	9c 01       	movw	r18, r24
 360:	2b 5e       	subi	r18, 0xEB	; 235
 362:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1098
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
 364:	dc 01       	movw	r26, r24
 366:	53 96       	adiw	r26, 0x13	; 19
 368:	ec 91       	ld	r30, X
 36a:	53 97       	sbiw	r26, 0x13	; 19
 36c:	52 96       	adiw	r26, 0x12	; 18
 36e:	8c 91       	ld	r24, X
 370:	e8 17       	cp	r30, r24
 372:	30 f4       	brcc	.+12     	; 0x380 <TwoWire::peek()+0x22>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1099
    return rxBuffer[(*rxTail)];
 374:	e2 0f       	add	r30, r18
 376:	f3 2f       	mov	r31, r19
 378:	f1 1d       	adc	r31, r1
 37a:	80 81       	ld	r24, Z
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1101
  } else {      // No bytes to read
    return -1;
 380:	8f ef       	ldi	r24, 0xFF	; 255
 382:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1103
  }
}
 384:	08 95       	ret

00000386 <TwoWire::read()>:
read():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1015
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
 386:	fc 01       	movw	r30, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1028
    } else
  #endif
  {
    rxHead   = &(_bytesToReadWrite);
    rxTail   = &(_bytesReadWritten);
    rxBuffer =   _hostBuffer;
 388:	dc 01       	movw	r26, r24
 38a:	55 96       	adiw	r26, 0x15	; 21
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1032
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
 38c:	93 89       	ldd	r25, Z+19	; 0x13
 38e:	82 89       	ldd	r24, Z+18	; 0x12
 390:	98 17       	cp	r25, r24
 392:	40 f4       	brcc	.+16     	; 0x3a4 <TwoWire::read()+0x1e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1033
    uint8_t c = rxBuffer[(*rxTail)];
 394:	a9 0f       	add	r26, r25
 396:	b1 1d       	adc	r27, r1
 398:	2c 91       	ld	r18, X
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1034
    (*rxTail)++;
 39a:	9f 5f       	subi	r25, 0xFF	; 255
 39c:	93 8b       	std	Z+19, r25	; 0x13
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1035
    return c;
 39e:	82 2f       	mov	r24, r18
 3a0:	90 e0       	ldi	r25, 0x00	; 0
 3a2:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1037
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
 3a4:	8f ef       	ldi	r24, 0xFF	; 255
 3a6:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1039
  }
}
 3a8:	08 95       	ret

000003aa <TwoWire::write(unsigned char)>:
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:928
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
 3aa:	fc 01       	movw	r30, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:944
    txBuffer =   _hostBuffer;
  }

  /* Put byte in txBuffer */

  if ((*txHead) < TWI_BUFFER_LENGTH) {    // while buffer not full, write to it
 3ac:	a2 89       	ldd	r26, Z+18	; 0x12
 3ae:	a0 32       	cpi	r26, 0x20	; 32
 3b0:	58 f4       	brcc	.+22     	; 0x3c8 <TwoWire::write(unsigned char)+0x1e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:945
    txBuffer[(*txHead)] = data;             // Load data into the buffer
 3b2:	a8 0f       	add	r26, r24
 3b4:	b9 2f       	mov	r27, r25
 3b6:	b1 1d       	adc	r27, r1
 3b8:	55 96       	adiw	r26, 0x15	; 21
 3ba:	6c 93       	st	X, r22
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:946
    (*txHead)++;                            // advancing the head
 3bc:	82 89       	ldd	r24, Z+18	; 0x12
 3be:	8f 5f       	subi	r24, 0xFF	; 255
 3c0:	82 8b       	std	Z+18, r24	; 0x12
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:947
    return 1;
 3c2:	81 e0       	ldi	r24, 0x01	; 1
 3c4:	90 e0       	ldi	r25, 0x00	; 0
 3c6:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:949
  } else {
    return 0;
 3c8:	90 e0       	ldi	r25, 0x00	; 0
 3ca:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:951
  }
}
 3cc:	08 95       	ret

000003ce <TwoWire::write(int) [clone .constprop.27]>:
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.h:290
    }
    inline size_t write(unsigned int  n) {
      return      write((uint8_t)     n);
    }
    inline size_t write(int           n) {
      return      write((uint8_t)     n);
 3ce:	68 2f       	mov	r22, r24
 3d0:	8e e3       	ldi	r24, 0x3E	; 62
 3d2:	9f e3       	ldi	r25, 0x3F	; 63
 3d4:	ea cf       	rjmp	.-44     	; 0x3aa <TwoWire::write(unsigned char)>

000003d6 <TwoWire::write(unsigned char const*, unsigned int)>:
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:966
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
 3d6:	bf 92       	push	r11
 3d8:	cf 92       	push	r12
 3da:	df 92       	push	r13
 3dc:	ef 92       	push	r14
 3de:	ff 92       	push	r15
 3e0:	0f 93       	push	r16
 3e2:	1f 93       	push	r17
 3e4:	cf 93       	push	r28
 3e6:	df 93       	push	r29
 3e8:	7c 01       	movw	r14, r24
 3ea:	6a 01       	movw	r12, r20
 3ec:	b6 2e       	mov	r11, r22
 3ee:	eb 01       	movw	r28, r22
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:968
  twi_buf_index_t i = 0;
  for (; i < quantity; i++) {
 3f0:	0c 2f       	mov	r16, r28
 3f2:	0b 19       	sub	r16, r11
 3f4:	10 e0       	ldi	r17, 0x00	; 0
 3f6:	0c 15       	cp	r16, r12
 3f8:	1d 05       	cpc	r17, r13
 3fa:	28 f4       	brcc	.+10     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:969
    if (TwoWire::write(*(data++)) == 0)
 3fc:	69 91       	ld	r22, Y+
 3fe:	c7 01       	movw	r24, r14
 400:	d4 df       	rcall	.-88     	; 0x3aa <TwoWire::write(unsigned char)>
 402:	89 2b       	or	r24, r25
 404:	a9 f7       	brne	.-22     	; 0x3f0 <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:974
      break;   // break if buffer full
  }

  return i;
}
 406:	c8 01       	movw	r24, r16
 408:	df 91       	pop	r29
 40a:	cf 91       	pop	r28
 40c:	1f 91       	pop	r17
 40e:	0f 91       	pop	r16
 410:	ff 90       	pop	r15
 412:	ef 90       	pop	r14
 414:	df 90       	pop	r13
 416:	cf 90       	pop	r12
 418:	bf 90       	pop	r11
 41a:	08 95       	ret

0000041c <Print::availableForWrite()>:
availableForWrite():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 41c:	90 e0       	ldi	r25, 0x00	; 0
 41e:	80 e0       	ldi	r24, 0x00	; 0
 420:	08 95       	ret

00000422 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]>:
printNumber():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:215
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 422:	8f 92       	push	r8
 424:	9f 92       	push	r9
 426:	af 92       	push	r10
 428:	bf 92       	push	r11
 42a:	0f 93       	push	r16
 42c:	1f 93       	push	r17
 42e:	cf 93       	push	r28
 430:	df 93       	push	r29
 432:	cd b7       	in	r28, 0x3d	; 61
 434:	de b7       	in	r29, 0x3e	; 62
 436:	a1 97       	sbiw	r28, 0x21	; 33
 438:	cd bf       	out	0x3d, r28	; 61
 43a:	de bf       	out	0x3e, r29	; 62
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:219
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 43c:	19 a2       	std	Y+33, r1	; 0x21
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:222

  // prevent crash if called with base == 1
  if (base < 2) {
 43e:	42 30       	cpi	r20, 0x02	; 2
 440:	08 f4       	brcc	.+2      	; 0x444 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]+0x22>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:223
    base = 10;
 442:	4a e0       	ldi	r20, 0x0A	; 10
 444:	8e 01       	movw	r16, r28
 446:	0f 5d       	subi	r16, 0xDF	; 223
 448:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:227
  }

  do {
    char c = n % base;
 44a:	84 2e       	mov	r8, r20
 44c:	91 2c       	mov	r9, r1
 44e:	b1 2c       	mov	r11, r1
 450:	a1 2c       	mov	r10, r1
 452:	a5 01       	movw	r20, r10
 454:	94 01       	movw	r18, r8
 456:	c7 d3       	rcall	.+1934   	; 0xbe6 <__udivmodsi4>
 458:	e6 2f       	mov	r30, r22
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:228
    n /= base;
 45a:	b9 01       	movw	r22, r18
 45c:	ca 01       	movw	r24, r20
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 45e:	ea 30       	cpi	r30, 0x0A	; 10
 460:	24 f5       	brge	.+72     	; 0x4aa <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]+0x88>
 462:	e0 5d       	subi	r30, 0xD0	; 208
 464:	d8 01       	movw	r26, r16
 466:	ee 93       	st	-X, r30
 468:	8d 01       	movw	r16, r26
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:231
  } while (n);
 46a:	23 2b       	or	r18, r19
 46c:	24 2b       	or	r18, r20
 46e:	25 2b       	or	r18, r21
 470:	81 f7       	brne	.-32     	; 0x452 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]+0x30>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.h:54
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
 472:	90 e0       	ldi	r25, 0x00	; 0
 474:	80 e0       	ldi	r24, 0x00	; 0
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
 476:	10 97       	sbiw	r26, 0x00	; 0
 478:	61 f0       	breq	.+24     	; 0x492 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]+0x70>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.h:56
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
 47a:	fd 01       	movw	r30, r26
 47c:	01 90       	ld	r0, Z+
 47e:	00 20       	and	r0, r0
 480:	e9 f7       	brne	.-6      	; 0x47c <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]+0x5a>
 482:	31 97       	sbiw	r30, 0x01	; 1
 484:	af 01       	movw	r20, r30
 486:	4a 1b       	sub	r20, r26
 488:	5b 0b       	sbc	r21, r27
 48a:	bd 01       	movw	r22, r26
 48c:	8b e0       	ldi	r24, 0x0B	; 11
 48e:	9f e3       	ldi	r25, 0x3F	; 63
 490:	78 de       	rcall	.-784    	; 0x182 <Print::write(unsigned char const*, unsigned int)>
printNumber():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:234

  return write(str);
}
 492:	a1 96       	adiw	r28, 0x21	; 33
 494:	cd bf       	out	0x3d, r28	; 61
 496:	de bf       	out	0x3e, r29	; 62
 498:	df 91       	pop	r29
 49a:	cf 91       	pop	r28
 49c:	1f 91       	pop	r17
 49e:	0f 91       	pop	r16
 4a0:	bf 90       	pop	r11
 4a2:	af 90       	pop	r10
 4a4:	9f 90       	pop	r9
 4a6:	8f 90       	pop	r8
 4a8:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:230

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 4aa:	e9 5c       	subi	r30, 0xC9	; 201
 4ac:	db cf       	rjmp	.-74     	; 0x464 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]+0x42>

000004ae <Print::print(long, int) [clone .part.3] [clone .constprop.13]>:
_ZN5Print5printEli.part.3():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:86

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base) {
 4ae:	cf 92       	push	r12
 4b0:	df 92       	push	r13
 4b2:	ef 92       	push	r14
 4b4:	ff 92       	push	r15
 4b6:	cf 93       	push	r28
 4b8:	df 93       	push	r29
 4ba:	6b 01       	movw	r12, r22
 4bc:	7c 01       	movw	r14, r24
print():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:71
size_t Print::print(const char str[]) {
  return write(str);
}

size_t Print::print(char c) {
  return write(c);
 4be:	6d e2       	ldi	r22, 0x2D	; 45
 4c0:	8b e0       	ldi	r24, 0x0B	; 11
 4c2:	9f e3       	ldi	r25, 0x3F	; 63
 4c4:	e6 de       	rcall	.-564    	; 0x292 <HardwareSerial::write(unsigned char)>
 4c6:	ec 01       	movw	r28, r24
_ZN5Print5printEli.part.3():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:92
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
      n = -n;
 4c8:	66 27       	eor	r22, r22
 4ca:	77 27       	eor	r23, r23
 4cc:	cb 01       	movw	r24, r22
 4ce:	6c 19       	sub	r22, r12
 4d0:	7d 09       	sbc	r23, r13
 4d2:	8e 09       	sbc	r24, r14
 4d4:	9f 09       	sbc	r25, r15
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:93
      return printNumber(n, 10) + t;
 4d6:	4a e0       	ldi	r20, 0x0A	; 10
 4d8:	a4 df       	rcall	.-184    	; 0x422 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:99
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 4da:	8c 0f       	add	r24, r28
 4dc:	9d 1f       	adc	r25, r29
 4de:	df 91       	pop	r29
 4e0:	cf 91       	pop	r28
 4e2:	ff 90       	pop	r15
 4e4:	ef 90       	pop	r14
 4e6:	df 90       	pop	r13
 4e8:	cf 90       	pop	r12
 4ea:	08 95       	ret

000004ec <pinMode>:
pinMode():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 4ec:	86 30       	cpi	r24, 0x06	; 6
 4ee:	f0 f4       	brcc	.+60     	; 0x52c <pinMode+0x40>
check_valid_digital_pin():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/Arduino.h:888
#if !defined(NUM_TOTAL_PINS)
  #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
#endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
 4f0:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:44
 4f2:	fc 01       	movw	r30, r24
 4f4:	e2 56       	subi	r30, 0x62	; 98
 4f6:	f3 47       	sbci	r31, 0x73	; 115
 4f8:	20 81       	ld	r18, Z
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:45
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
 4fa:	2f 3f       	cpi	r18, 0xFF	; 255
 4fc:	b9 f0       	breq	.+46     	; 0x52c <pinMode+0x40>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:48
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
 4fe:	fc 01       	movw	r30, r24
 500:	e8 56       	subi	r30, 0x68	; 104
 502:	f3 47       	sbci	r31, 0x73	; 115
 504:	e0 81       	ld	r30, Z
 506:	30 e2       	ldi	r19, 0x20	; 32
 508:	e3 9f       	mul	r30, r19
 50a:	f0 01       	movw	r30, r0
 50c:	11 24       	eor	r1, r1
 50e:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:49
  if (mode & 0x01) {
 510:	61 30       	cpi	r22, 0x01	; 1
 512:	69 f4       	brne	.+26     	; 0x52e <pinMode+0x42>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:51
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 514:	21 83       	std	Z+1, r18	; 0x01
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:77
  // then load with displacement 2 clocks. IFF the compiler puts this pointer into Y or Z, it is faster and smaller
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
 516:	8e 56       	subi	r24, 0x6E	; 110
 518:	93 47       	sbci	r25, 0x73	; 115
 51a:	dc 01       	movw	r26, r24
 51c:	8c 91       	ld	r24, X
 51e:	e8 0f       	add	r30, r24
 520:	f1 1d       	adc	r31, r1
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:78
  bit_mask = *(port_base + 0x10);
 522:	80 89       	ldd	r24, Z+16	; 0x10
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:79
  if (mode & 2) {
 524:	61 30       	cpi	r22, 0x01	; 1
 526:	29 f0       	breq	.+10     	; 0x532 <pinMode+0x46>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:80
    bit_mask |= 0x08;
 528:	88 60       	ori	r24, 0x08	; 8
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:84
  } else {
    bit_mask &= 0xF7;
  }
  *(port_base + 0x10) = bit_mask;
 52a:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:85
}
 52c:	08 95       	ret
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:53
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
  } else { // otherwise it's input so we write DIRCLR
    *(port_base + 2) = bit_mask;
 52e:	22 83       	std	Z+2, r18	; 0x02
 530:	f2 cf       	rjmp	.-28     	; 0x516 <pinMode+0x2a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:82
  port_base += (uint8_t) digitalPinToBitPosition(pin);
  bit_mask = *(port_base + 0x10);
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 532:	87 7f       	andi	r24, 0xF7	; 247
 534:	fa cf       	rjmp	.-12     	; 0x52a <pinMode+0x3e>

00000536 <__vector_9>:
__vector_9():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_micros_ISR.h:839
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      // Common Interrupt header for TCB, TCA and TCD;
      // Clears the Timer Interrupt flag and pushes the CPU Registers
      // 7 words / 7 clocks
      __asm__ __volatile__(
 536:	8f 93       	push	r24
 538:	82 e0       	ldi	r24, 0x02	; 2
 53a:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <vtable for TwoWire+0x7f7d55>
 53e:	8f b7       	in	r24, 0x3f	; 63
 540:	8f 93       	push	r24
 542:	ef 93       	push	r30
 544:	ff 93       	push	r31
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_micros_ISR.h:950
        [MIINC]  "M" ((0x0000 - MILLIS_INC) & 0xFF),
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
  */

      __asm__ __volatile__(
 546:	e1 e0       	ldi	r30, 0x01	; 1
 548:	ff e3       	ldi	r31, 0x3F	; 63
 54a:	9f 93       	push	r25
 54c:	68 94       	set
 54e:	8f ef       	ldi	r24, 0xFF	; 255
 550:	0d c0       	rjmp	.+26     	; 0x56c <sub4>

00000552 <ovf_end>:
 552:	e8 94       	clt
 554:	84 81       	ldd	r24, Z+4	; 0x04
 556:	95 81       	ldd	r25, Z+5	; 0x05
 558:	80 5d       	subi	r24, 0xD0	; 208
 55a:	9c 4f       	sbci	r25, 0xFC	; 252
 55c:	84 83       	std	Z+4, r24	; 0x04
 55e:	95 83       	std	Z+5, r25	; 0x05
 560:	88 5e       	subi	r24, 0xE8	; 232
 562:	93 40       	sbci	r25, 0x03	; 3
 564:	80 f0       	brcs	.+32     	; 0x586 <sub_end>
 566:	84 83       	std	Z+4, r24	; 0x04
 568:	95 83       	std	Z+5, r25	; 0x05
 56a:	8f ef       	ldi	r24, 0xFF	; 255

0000056c <sub4>:
 56c:	90 81       	ld	r25, Z
 56e:	98 1b       	sub	r25, r24
 570:	91 93       	st	Z+, r25
 572:	90 81       	ld	r25, Z
 574:	9f 4f       	sbci	r25, 0xFF	; 255
 576:	91 93       	st	Z+, r25
 578:	90 81       	ld	r25, Z
 57a:	9f 4f       	sbci	r25, 0xFF	; 255
 57c:	91 93       	st	Z+, r25
 57e:	90 81       	ld	r25, Z
 580:	9f 4f       	sbci	r25, 0xFF	; 255
 582:	91 93       	st	Z+, r25
 584:	36 f3       	brts	.-52     	; 0x552 <ovf_end>

00000586 <sub_end>:
 586:	9f 91       	pop	r25
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_micros_ISR.h:1012
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
    #endif /* (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) */
    // Common ISR Epilogue for TCA, TCB and TCD, popping register in reverse Order
    // 6 words, 14 clocks
    __asm__ __volatile__(
 588:	ff 91       	pop	r31
 58a:	ef 91       	pop	r30
 58c:	8f 91       	pop	r24
 58e:	8f bf       	out	0x3f, r24	; 63
 590:	8f 91       	pop	r24
 592:	18 95       	reti

00000594 <__vector_23>:
__vector_23():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART0.cpp:118
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"       "\n\t"
                "push  r31"       "\n\t"
                "cbi   0x1F, 0"   "\n\t"
                :::);
 594:	ef 93       	push	r30
 596:	ff 93       	push	r31
 598:	f8 98       	cbi	0x1f, 0	; 31
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART0.cpp:125
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"     "\n\t"
#else
                "rjmp _do_dre"    "\n\t"
#endif
                ::"z"(&Serial0));
 59a:	eb e0       	ldi	r30, 0x0B	; 11
 59c:	ff e3       	ldi	r31, 0x3F	; 63
 59e:	0b c0       	rjmp	.+22     	; 0x5b6 <_do_dre()>

000005a0 <__vector_22>:
__vector_22():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART0.cpp:95
      ISR(USART0_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              "cbi   0x1F, 0"     "\n\t"
              :::);
 5a0:	ef 93       	push	r30
 5a2:	ff 93       	push	r31
 5a4:	f8 98       	cbi	0x1f, 0	; 31
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART0.cpp:102
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial0));
 5a6:	eb e0       	ldi	r30, 0x0B	; 11
 5a8:	ff e3       	ldi	r31, 0x3F	; 63
 5aa:	32 c0       	rjmp	.+100    	; 0x610 <_do_rxc()>

000005ac <__vector_24>:
__vector_24():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART0.cpp:58
#elif defined(USE_ASM_TXC) && USE_ASM_TXC == 2
    ISR(USART0_TXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t"
              "push      r31"     "\n\t"
              :::);
 5ac:	ef 93       	push	r30
 5ae:	ff 93       	push	r31
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART0.cpp:65
#if PROGMEM_SIZE > 8192
              "jmp   _do_txc"     "\n\t"
#else
              "rjmp   _do_txc"    "\n\t"
#endif
              ::"z"(&Serial0));
 5b0:	eb e0       	ldi	r30, 0x0B	; 11
 5b2:	ff e3       	ldi	r31, 0x3F	; 63
 5b4:	5a c0       	rjmp	.+180    	; 0x66a <_do_txc()>

000005b6 <_do_dre()>:
_Z7_do_drev():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:384
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
 5b6:	2f 93       	push	r18
 5b8:	2f b7       	in	r18, 0x3f	; 63
 5ba:	2f 93       	push	r18
 5bc:	8f 93       	push	r24
 5be:	9f 93       	push	r25
 5c0:	af 93       	push	r26
 5c2:	bf 93       	push	r27
 5c4:	68 94       	set

000005c6 <_poll_dre>:
 5c6:	cf 93       	push	r28
 5c8:	df 93       	push	r29
 5ca:	20 e0       	ldi	r18, 0x00	; 0
 5cc:	c0 85       	ldd	r28, Z+8	; 0x08
 5ce:	d8 e0       	ldi	r29, 0x08	; 8
 5d0:	90 89       	ldd	r25, Z+16	; 0x10
 5d2:	df 01       	movw	r26, r30
 5d4:	a9 0f       	add	r26, r25
 5d6:	b2 1f       	adc	r27, r18
 5d8:	91 96       	adiw	r26, 0x21	; 33
 5da:	8c 91       	ld	r24, X
 5dc:	20 e4       	ldi	r18, 0x40	; 64
 5de:	2c 83       	std	Y+4, r18	; 0x04
 5e0:	8a 83       	std	Y+2, r24	; 0x02
 5e2:	9f 5f       	subi	r25, 0xFF	; 255
 5e4:	9f 70       	andi	r25, 0x0F	; 15
 5e6:	8d 81       	ldd	r24, Y+5	; 0x05
 5e8:	27 85       	ldd	r18, Z+15	; 0x0f
 5ea:	29 13       	cpse	r18, r25
 5ec:	02 c0       	rjmp	.+4      	; 0x5f2 <_done_dre_irq>
 5ee:	8f 7d       	andi	r24, 0xDF	; 223
 5f0:	8d 83       	std	Y+5, r24	; 0x05

000005f2 <_done_dre_irq>:
 5f2:	90 8b       	std	Z+16, r25	; 0x10
 5f4:	df 91       	pop	r29
 5f6:	cf 91       	pop	r28
 5f8:	0e f0       	brts	.+2      	; 0x5fc <_done_dre_irq+0xa>
 5fa:	4a ce       	rjmp	.-876    	; 0x290 <_poll_dre_done>
 5fc:	bf 91       	pop	r27
 5fe:	af 91       	pop	r26
 600:	9f 91       	pop	r25
 602:	8f 91       	pop	r24
 604:	2f 91       	pop	r18
 606:	2f bf       	out	0x3f, r18	; 63
 608:	2f 91       	pop	r18
 60a:	ff 91       	pop	r31
 60c:	ef 91       	pop	r30
 60e:	18 95       	reti

00000610 <_do_rxc()>:
_Z7_do_rxcv():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:249
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // potential improvement: move _buff_full_rxc to after the reti, and then rjmp back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
 610:	2f 93       	push	r18
 612:	2f b7       	in	r18, 0x3f	; 63
 614:	2f 93       	push	r18
 616:	3f 93       	push	r19
 618:	8f 93       	push	r24
 61a:	9f 93       	push	r25
 61c:	cf 93       	push	r28
 61e:	df 93       	push	r29
 620:	c0 85       	ldd	r28, Z+8	; 0x08
 622:	d8 e0       	ldi	r29, 0x08	; 8
 624:	89 81       	ldd	r24, Y+1	; 0x01
 626:	98 81       	ld	r25, Y
 628:	86 74       	andi	r24, 0x46	; 70
 62a:	88 0f       	add	r24, r24
 62c:	34 85       	ldd	r19, Z+12	; 0x0c
 62e:	38 2b       	or	r19, r24
 630:	82 fd       	sbrc	r24, 2
 632:	0d c0       	rjmp	.+26     	; 0x64e <_end_rxc>
 634:	c5 85       	ldd	r28, Z+13	; 0x0d
 636:	81 e0       	ldi	r24, 0x01	; 1
 638:	8c 0f       	add	r24, r28
 63a:	8f 70       	andi	r24, 0x0F	; 15
 63c:	26 85       	ldd	r18, Z+14	; 0x0e
 63e:	28 17       	cp	r18, r24
 640:	91 f0       	breq	.+36     	; 0x666 <_buff_full_rxc>
 642:	ce 0f       	add	r28, r30
 644:	df 2f       	mov	r29, r31
 646:	20 e0       	ldi	r18, 0x00	; 0
 648:	d2 1f       	adc	r29, r18
 64a:	99 8b       	std	Y+17, r25	; 0x11
 64c:	85 87       	std	Z+13, r24	; 0x0d

0000064e <_end_rxc>:
 64e:	34 87       	std	Z+12, r19	; 0x0c
 650:	df 91       	pop	r29
 652:	cf 91       	pop	r28
 654:	9f 91       	pop	r25
 656:	8f 91       	pop	r24
 658:	3f 91       	pop	r19
 65a:	2f 91       	pop	r18
 65c:	2f bf       	out	0x3f, r18	; 63
 65e:	2f 91       	pop	r18
 660:	ff 91       	pop	r31
 662:	ef 91       	pop	r30
 664:	18 95       	reti

00000666 <_buff_full_rxc>:
 666:	30 64       	ori	r19, 0x40	; 64
 668:	f2 cf       	rjmp	.-28     	; 0x64e <_end_rxc>

0000066a <_do_txc()>:
_Z7_do_txcv():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:124
            "pop        r24"              "\n\t"  // pop r24 restore it
            "pop        r31"              "\n\t"  // and r31
            "pop        r30"              "\n\t"  // Pop the register the ISR did
            "reti"                        "\n"    // return from the interrupt.
            ::
          );
 66a:	8f 93       	push	r24
 66c:	8f b7       	in	r24, 0x3f	; 63
 66e:	8f 93       	push	r24
 670:	9f 93       	push	r25
 672:	cf 93       	push	r28
 674:	df 93       	push	r29
 676:	c0 85       	ldd	r28, Z+8	; 0x08
 678:	d8 e0       	ldi	r29, 0x08	; 8
 67a:	9d 81       	ldd	r25, Y+5	; 0x05

0000067c <_txc_flush_rx>:
 67c:	88 81       	ld	r24, Y
 67e:	8c 81       	ldd	r24, Y+4	; 0x04
 680:	87 fd       	sbrc	r24, 7
 682:	fc cf       	rjmp	.-8      	; 0x67c <_txc_flush_rx>
 684:	9f 7b       	andi	r25, 0xBF	; 191
 686:	90 68       	ori	r25, 0x80	; 128
 688:	9d 83       	std	Y+5, r25	; 0x05
 68a:	df 91       	pop	r29
 68c:	cf 91       	pop	r28
 68e:	9f 91       	pop	r25
 690:	8f 91       	pop	r24
 692:	8f bf       	out	0x3f, r24	; 63
 694:	8f 91       	pop	r24
 696:	ff 91       	pop	r31
 698:	ef 91       	pop	r30
 69a:	18 95       	reti

0000069c <__vector_19>:
__vector_19():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1421


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
 69c:	1f 92       	push	r1
 69e:	0f 92       	push	r0
 6a0:	0f b6       	in	r0, 0x3f	; 63
 6a2:	0f 92       	push	r0
 6a4:	11 24       	eor	r1, r1
 6a6:	1f 93       	push	r17
 6a8:	2f 93       	push	r18
 6aa:	3f 93       	push	r19
 6ac:	4f 93       	push	r20
 6ae:	5f 93       	push	r21
 6b0:	6f 93       	push	r22
 6b2:	7f 93       	push	r23
 6b4:	8f 93       	push	r24
 6b6:	9f 93       	push	r25
 6b8:	af 93       	push	r26
 6ba:	bf 93       	push	r27
 6bc:	cf 93       	push	r28
 6be:	df 93       	push	r29
 6c0:	ef 93       	push	r30
 6c2:	ff 93       	push	r31
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1422
  TwoWire::HandleSlaveIRQ(twi0_wire);
 6c4:	c0 91 3c 3f 	lds	r28, 0x3F3C	; 0x803f3c <twi0_wire>
 6c8:	d0 91 3d 3f 	lds	r29, 0x3F3D	; 0x803f3d <twi0_wire+0x1>
HandleSlaveIRQ():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1291




void TwoWire::HandleSlaveIRQ(TwoWire *wire_s) {
  if (wire_s == NULL) {
 6cc:	20 97       	sbiw	r28, 0x00	; 0
 6ce:	b9 f1       	breq	.+110    	; 0x73e <__vector_19+0xa2>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1314
  #if defined(TWI_MANDS)
    wire_s->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
  uint8_t clientStatus = wire_s->_module->SSTATUS;
 6d0:	a8 85       	ldd	r26, Y+8	; 0x08
 6d2:	b9 85       	ldd	r27, Y+9	; 0x09
 6d4:	1b 96       	adiw	r26, 0x0b	; 11
 6d6:	1c 91       	ld	r17, X
 6d8:	1b 97       	sbiw	r26, 0x0b	; 11
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1317


  if (clientStatus & TWI_APIF_bm) {   // Address/Stop Bit set
 6da:	16 ff       	sbrs	r17, 6
 6dc:	53 c0       	rjmp	.+166    	; 0x784 <__vector_19+0xe8>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1318
    if (wire_s->_bools._hostDataSent != 0) { // At this point, we have either a START, REPSTART or a STOP
 6de:	8b 85       	ldd	r24, Y+11	; 0x0b
 6e0:	83 ff       	sbrs	r24, 3
 6e2:	09 c0       	rjmp	.+18     	; 0x6f6 <__vector_19+0x5a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1319
      wire_s->_bools._hostDataSent = 0x00;
 6e4:	87 7f       	andi	r24, 0xF7	; 247
 6e6:	8b 87       	std	Y+11, r24	; 0x0b
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1320
      if (wire_s->user_onReceive != NULL) {   // only if the last APIF was a Master Write,
 6e8:	ef 85       	ldd	r30, Y+15	; 0x0f
 6ea:	f8 89       	ldd	r31, Y+16	; 0x10
 6ec:	30 97       	sbiw	r30, 0x00	; 0
 6ee:	19 f0       	breq	.+6      	; 0x6f6 <__vector_19+0x5a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1321
        wire_s->user_onReceive((*head));      // we notify the sketch about new Data
 6f0:	8a 89       	ldd	r24, Y+18	; 0x12
 6f2:	90 e0       	ldi	r25, 0x00	; 0
 6f4:	09 95       	icall
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1325
      }
    }

    if (clientStatus & TWI_AP_bm) {     // Address bit set
 6f6:	10 ff       	sbrs	r17, 0
 6f8:	3b c0       	rjmp	.+118    	; 0x770 <__vector_19+0xd4>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1326
      if ((*head) == 0) {                 // only if there was no data (START)
 6fa:	8a 89       	ldd	r24, Y+18	; 0x12
 6fc:	81 11       	cpse	r24, r1
 6fe:	0b c0       	rjmp	.+22     	; 0x716 <__vector_19+0x7a>
pauseDeepSleep():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1465
    sleepStackLoc |= bit_mask;      // Remember which module is busy
    sleepStack = sleepStackLoc;
  #else
    (void) module_lower_Addr;

    if (sleepStack == 0x00) {
 700:	80 91 00 3f 	lds	r24, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 704:	81 11       	cpse	r24, r1
 706:	07 c0       	rjmp	.+14     	; 0x716 <__vector_19+0x7a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1466
      uint8_t slp = SLPCTRL.CTRLA;    // save current sleep State
 708:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <vtable for TwoWire+0x7f739a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1467
      sleepStack = slp;               // using local variable for less store/load
 70c:	80 93 00 3f 	sts	0x3F00, r24	; 0x803f00 <__DATA_REGION_ORIGIN__>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1468
      SLPCTRL.CTRLA = slp & 0x01;     // only leave the SEN bit, if it was set
 710:	81 70       	andi	r24, 0x01	; 1
 712:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <vtable for TwoWire+0x7f739a>
HandleSlaveIRQ():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1329

    if (clientStatus & TWI_AP_bm) {     // Address bit set
      if ((*head) == 0) {                 // only if there was no data (START)
        pauseDeepSleep((uint8_t)((uint16_t)wire_s->_module));  // Only START can wake from deep sleep, change to IDLE
      }
      (*head) = 0;
 716:	1a 8a       	std	Y+18, r1	; 0x12
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1330
      (*tail) = 0;
 718:	1b 8a       	std	Y+19, r1	; 0x13
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1331
      (*address) = wire_s->_module->SDATA;  // read address from data register
 71a:	e8 85       	ldd	r30, Y+8	; 0x08
 71c:	f9 85       	ldd	r31, Y+9	; 0x09
 71e:	85 85       	ldd	r24, Z+13	; 0x0d
 720:	89 8b       	std	Y+17, r24	; 0x11
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1332
      if (clientStatus & TWI_DIR_bm) {      // Master is reading
 722:	11 ff       	sbrs	r17, 1
 724:	20 c0       	rjmp	.+64     	; 0x766 <__vector_19+0xca>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1333
        if (wire_s->user_onRequest != NULL) {
 726:	ed 85       	ldd	r30, Y+13	; 0x0d
 728:	fe 85       	ldd	r31, Y+14	; 0x0e
 72a:	30 97       	sbiw	r30, 0x00	; 0
 72c:	09 f0       	breq	.+2      	; 0x730 <__vector_19+0x94>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1334
          wire_s->user_onRequest();
 72e:	09 95       	icall
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1336
        }
        if ((*head) == 0) {                     // If no data to transmit, send NACK
 730:	8a 89       	ldd	r24, Y+18	; 0x12
 732:	81 11       	cpse	r24, r1
 734:	1b c0       	rjmp	.+54     	; 0x76c <__vector_19+0xd0>
__vector_19():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1337
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
 736:	86 e0       	ldi	r24, 0x06	; 6
HandleSlaveIRQ():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1382
          action = TWI_SCMD_RESPONSE_gc;            // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      }
    }
  }
  wire_s->_module->SCTRLB = action;  // using local variable (register) reduces the amount of loading _module
 738:	e8 85       	ldd	r30, Y+8	; 0x08
 73a:	f9 85       	ldd	r31, Y+9	; 0x09
 73c:	82 87       	std	Z+10, r24	; 0x0a
__vector_19():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1423
/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
  TwoWire::HandleSlaveIRQ(twi0_wire);
}
 73e:	ff 91       	pop	r31
 740:	ef 91       	pop	r30
 742:	df 91       	pop	r29
 744:	cf 91       	pop	r28
 746:	bf 91       	pop	r27
 748:	af 91       	pop	r26
 74a:	9f 91       	pop	r25
 74c:	8f 91       	pop	r24
 74e:	7f 91       	pop	r23
 750:	6f 91       	pop	r22
 752:	5f 91       	pop	r21
 754:	4f 91       	pop	r20
 756:	3f 91       	pop	r19
 758:	2f 91       	pop	r18
 75a:	1f 91       	pop	r17
 75c:	0f 90       	pop	r0
 75e:	0f be       	out	0x3f, r0	; 63
 760:	0f 90       	pop	r0
 762:	1f 90       	pop	r1
 764:	18 95       	reti
HandleSlaveIRQ():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1342
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        wire_s->_bools._hostDataSent = 0x01;
 766:	8b 85       	ldd	r24, Y+11	; 0x0b
 768:	88 60       	ori	r24, 0x08	; 8
 76a:	8b 87       	std	Y+11, r24	; 0x0b
__vector_19():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1343
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by slave data interrupt"
 76c:	83 e0       	ldi	r24, 0x03	; 3
 76e:	e4 cf       	rjmp	.-56     	; 0x738 <__vector_19+0x9c>
restoreSleep():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1490
      }
    }
    sleepStack = sleepStackLoc;
  #else
    (void) module_lower_Addr;
    SLPCTRL.CTRLA = sleepStack;
 770:	80 91 00 3f 	lds	r24, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 774:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <vtable for TwoWire+0x7f739a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1491
    sleepStack = 0;
 778:	10 92 00 3f 	sts	0x3F00, r1	; 0x803f00 <__DATA_REGION_ORIGIN__>
HandleSlaveIRQ():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1347
        wire_s->_bools._hostDataSent = 0x01;
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by slave data interrupt"
      }
    } else {                          // Stop bit set
      restoreSleep((uint8_t)((uint16_t)wire_s->_module));
      (*head) = 0;
 77c:	1a 8a       	std	Y+18, r1	; 0x12
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1348
      (*tail) = 0;
 77e:	1b 8a       	std	Y+19, r1	; 0x13
__vector_19():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1366
          wire_s->_module->SDATA = buffer[(*tail)];  // Writing to the register to send data
          (*tail)++;                              // Increment counter for sent bytes
          action = TWI_SCMD_RESPONSE_gc;          // "Execute Acknowledge Action succeeded by reception of next byte"
        } else {                                  // No more data available
          (*head) = 0;                            // Avoid triggering REPSTART handler
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
 780:	82 e0       	ldi	r24, 0x02	; 2
 782:	da cf       	rjmp	.-76     	; 0x738 <__vector_19+0x9c>
HandleSlaveIRQ():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1351
      restoreSleep((uint8_t)((uint16_t)wire_s->_module));
      (*head) = 0;
      (*tail) = 0;
      action = TWI_SCMD_COMPTRANS_gc;  // "Wait for any Start (S/Sr) condition"
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
 784:	17 ff       	sbrs	r17, 7
 786:	2e c0       	rjmp	.+92     	; 0x7e4 <__vector_19+0x148>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1306
    buffer  =   wire_s->_clientBuffer;
  #else
    address = &(wire_s->_clientAddress);
    head    = &(wire_s->_bytesToReadWrite);
    tail    = &(wire_s->_bytesReadWritten);
    buffer  =   wire_s->_hostBuffer;
 788:	9e 01       	movw	r18, r28
 78a:	2b 5e       	subi	r18, 0xEB	; 235
 78c:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1352
      (*head) = 0;
      (*tail) = 0;
      action = TWI_SCMD_COMPTRANS_gc;  // "Wait for any Start (S/Sr) condition"
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
 78e:	11 ff       	sbrs	r17, 1
 790:	1a c0       	rjmp	.+52     	; 0x7c6 <__vector_19+0x12a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1353
      if (clientStatus & wire_s->client_irq_mask) {   // If a collision was detected, or RXACK bit is set (when it matters)
 792:	8a 85       	ldd	r24, Y+10	; 0x0a
 794:	18 23       	and	r17, r24
 796:	21 f0       	breq	.+8      	; 0x7a0 <__vector_19+0x104>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1354
        wire_s->client_irq_mask = TWI_COLL_bm;  // stop checking for NACK
 798:	88 e0       	ldi	r24, 0x08	; 8
 79a:	8a 87       	std	Y+10, r24	; 0x0a
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1365
        if ((*tail) < (*head)) {                // Data is available
          wire_s->_module->SDATA = buffer[(*tail)];  // Writing to the register to send data
          (*tail)++;                              // Increment counter for sent bytes
          action = TWI_SCMD_RESPONSE_gc;          // "Execute Acknowledge Action succeeded by reception of next byte"
        } else {                                  // No more data available
          (*head) = 0;                            // Avoid triggering REPSTART handler
 79c:	1a 8a       	std	Y+18, r1	; 0x12
 79e:	f0 cf       	rjmp	.-32     	; 0x780 <__vector_19+0xe4>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1358
      if (clientStatus & wire_s->client_irq_mask) {   // If a collision was detected, or RXACK bit is set (when it matters)
        wire_s->client_irq_mask = TWI_COLL_bm;  // stop checking for NACK
        (*head) = 0;                            // Abort further data writes
        action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
      } else {                                // RXACK bit not set, no COLL
        wire_s->_bytesTransmittedS++;           // increment bytes transmitted counter (for register model)
 7a0:	8c 89       	ldd	r24, Y+20	; 0x14
 7a2:	8f 5f       	subi	r24, 0xFF	; 255
 7a4:	8c 8b       	std	Y+20, r24	; 0x14
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1359
        wire_s->client_irq_mask = TWI_COLL_bm | TWI_RXACK_bm;  // start checking for NACK
 7a6:	88 e1       	ldi	r24, 0x18	; 24
 7a8:	8a 87       	std	Y+10, r24	; 0x0a
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1360
        if ((*tail) < (*head)) {                // Data is available
 7aa:	eb 89       	ldd	r30, Y+19	; 0x13
 7ac:	8a 89       	ldd	r24, Y+18	; 0x12
 7ae:	e8 17       	cp	r30, r24
 7b0:	a8 f7       	brcc	.-22     	; 0x79c <__vector_19+0x100>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1361
          wire_s->_module->SDATA = buffer[(*tail)];  // Writing to the register to send data
 7b2:	e2 0f       	add	r30, r18
 7b4:	f3 2f       	mov	r31, r19
 7b6:	f1 1d       	adc	r31, r1
 7b8:	80 81       	ld	r24, Z
 7ba:	1d 96       	adiw	r26, 0x0d	; 13
 7bc:	8c 93       	st	X, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1362
          (*tail)++;                              // Increment counter for sent bytes
 7be:	8b 89       	ldd	r24, Y+19	; 0x13
 7c0:	8f 5f       	subi	r24, 0xFF	; 255
 7c2:	8b 8b       	std	Y+19, r24	; 0x13
 7c4:	d3 cf       	rjmp	.-90     	; 0x76c <__vector_19+0xd0>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1370
          (*head) = 0;                            // Avoid triggering REPSTART handler
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
        }
      }
    } else {                                  // Master is writing
      uint8_t payload = wire_s->_module->SDATA;     // reading SDATA will clear the DATA IRQ flag
 7c6:	1d 96       	adiw	r26, 0x0d	; 13
 7c8:	8c 91       	ld	r24, X
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1371
      if ((*head) < TWI_BUFFER_LENGTH) {            // make sure that we don't have a buffer overflow in case Master ignores NACK
 7ca:	ea 89       	ldd	r30, Y+18	; 0x12
 7cc:	e0 32       	cpi	r30, 0x20	; 32
 7ce:	50 f4       	brcc	.+20     	; 0x7e4 <__vector_19+0x148>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1372
        buffer[(*head)] = payload;                  // save data
 7d0:	e2 0f       	add	r30, r18
 7d2:	f3 2f       	mov	r31, r19
 7d4:	f1 1d       	adc	r31, r1
 7d6:	80 83       	st	Z, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1373
        (*head)++;                                  // Advance Head
 7d8:	8a 89       	ldd	r24, Y+18	; 0x12
 7da:	8f 5f       	subi	r24, 0xFF	; 255
 7dc:	8a 8b       	std	Y+18, r24	; 0x12
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1374
        if ((*head) == TWI_BUFFER_LENGTH) {         // if buffer is not yet full
 7de:	80 32       	cpi	r24, 0x20	; 32
 7e0:	29 f6       	brne	.-118    	; 0x76c <__vector_19+0xd0>
 7e2:	a9 cf       	rjmp	.-174    	; 0x736 <__vector_19+0x9a>
__vector_19():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:1313

  #if defined(TWI_MANDS)
    wire_s->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
 7e4:	80 e0       	ldi	r24, 0x00	; 0
 7e6:	a8 cf       	rjmp	.-176    	; 0x738 <__vector_19+0x9c>

000007e8 <global constructors keyed to 65535_0_ATtiny402_HTCO2.ino.cpp.o.2699>:
_GLOBAL__I_65535_0_ATtiny402_HTCO2.ino.cpp.o.2699():
 7e8:	eb e0       	ldi	r30, 0x0B	; 11
 7ea:	ff e3       	ldi	r31, 0x3F	; 63
 7ec:	12 82       	std	Z+2, r1	; 0x02
 7ee:	13 82       	std	Z+3, r1	; 0x03
 7f0:	88 ee       	ldi	r24, 0xE8	; 232
 7f2:	93 e0       	ldi	r25, 0x03	; 3
 7f4:	a0 e0       	ldi	r26, 0x00	; 0
 7f6:	b0 e0       	ldi	r27, 0x00	; 0
 7f8:	84 83       	std	Z+4, r24	; 0x04
 7fa:	95 83       	std	Z+5, r25	; 0x05
 7fc:	a6 83       	std	Z+6, r26	; 0x06
 7fe:	b7 83       	std	Z+7, r27	; 0x07
 800:	28 ea       	ldi	r18, 0xA8	; 168
 802:	3c e8       	ldi	r19, 0x8C	; 140
 804:	20 83       	st	Z, r18
 806:	31 83       	std	Z+1, r19	; 0x01
 808:	20 e0       	ldi	r18, 0x00	; 0
 80a:	38 e0       	ldi	r19, 0x08	; 8
 80c:	20 87       	std	Z+8, r18	; 0x08
 80e:	31 87       	std	Z+9, r19	; 0x09
 810:	12 86       	std	Z+10, r1	; 0x0a
 812:	13 86       	std	Z+11, r1	; 0x0b
 814:	ee e3       	ldi	r30, 0x3E	; 62
 816:	ff e3       	ldi	r31, 0x3F	; 63
 818:	12 82       	std	Z+2, r1	; 0x02
 81a:	13 82       	std	Z+3, r1	; 0x03
 81c:	84 83       	std	Z+4, r24	; 0x04
 81e:	95 83       	std	Z+5, r25	; 0x05
 820:	a6 83       	std	Z+6, r26	; 0x06
 822:	b7 83       	std	Z+7, r27	; 0x07
 824:	8a eb       	ldi	r24, 0xBA	; 186
 826:	9c e8       	ldi	r25, 0x8C	; 140
 828:	80 83       	st	Z, r24
 82a:	91 83       	std	Z+1, r25	; 0x01
 82c:	e0 93 3c 3f 	sts	0x3F3C, r30	; 0x803f3c <twi0_wire>
 830:	f0 93 3d 3f 	sts	0x3F3D, r31	; 0x803f3d <twi0_wire+0x1>
 834:	80 e1       	ldi	r24, 0x10	; 16
 836:	98 e0       	ldi	r25, 0x08	; 8
 838:	80 87       	std	Z+8, r24	; 0x08
 83a:	91 87       	std	Z+9, r25	; 0x09
 83c:	08 95       	ret

0000083e <main>:
main():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/main.cpp:49
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
 83e:	cf 93       	push	r28
 840:	df 93       	push	r29
 842:	cd b7       	in	r28, 0x3d	; 61
 844:	de b7       	in	r29, 0x3e	; 62
 846:	25 97       	sbiw	r28, 0x05	; 5
 848:	cd bf       	out	0x3d, r28	; 61
 84a:	de bf       	out	0x3e, r29	; 62
init_clock():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:460
  #if (CLOCK_SOURCE == 0)
    #if (defined(CLOCK_TUNE_INTERNAL))
      tune_internal(); // Will be inlined as only called once. Just too long and ugly to put two implementations in middle of this.
    #else
      #if defined(_MCLK_CTRLB) && defined(F_CPU) && defined(_MAIN_CLOCK_PRESCALER)
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB,_MCLK_CTRLB);
 84c:	88 ed       	ldi	r24, 0xD8	; 216
 84e:	90 e0       	ldi	r25, 0x00	; 0
 850:	84 bf       	out	0x34, r24	; 52
 852:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <vtable for TwoWire+0x7f73ab>
init_ADC0():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:552


/********************************* ADC ****************************************/
void __attribute__((weak)) init_ADC0() {
  ADC_t* pADC;
  _fastPtr_d(pADC, &ADC0);
 856:	e0 e0       	ldi	r30, 0x00	; 0
 858:	f6 e0       	ldi	r31, 0x06	; 6
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:573
   **************************************************************************/
    //                              30 MHz / 32 = 937 kHz,  32 MHz / 32 =  1 MHz.
    #if   F_CPU   > 24000000     // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      pADC->CTRLC  = ADC_PRESC_DIV32_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      pADC->CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
 85a:	83 e5       	ldi	r24, 0x53	; 83
 85c:	82 83       	std	Z+2, r24	; 0x02
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:584
      pADC->CTRLC  =  ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #endif
    #if   (F_CPU == 6000000 || F_CPU == 12000000 || F_CPU == 24000000 || F_CPU ==25000000)
      pADC->SAMPCTRL = (7); // 9 ADC clocks, 12 us
    #elif (F_CPU == 5000000 || F_CPU == 10000000 || F_CPU == 20000000)
      pADC->SAMPCTRL = (13);   // 15 ADC clock,s 12 us
 85e:	8d e0       	ldi	r24, 0x0D	; 13
 860:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:588
    #else
      pADC->SAMPCTRL = (10); // 12 ADC clocks, 12 us
    #endif
    pADC->CTRLD    = ADC_INITDLY_DLY16_gc;
 862:	80 e2       	ldi	r24, 0x20	; 32
 864:	83 83       	std	Z+3, r24	; 0x03
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:589
    pADC->CTRLA    = ADC_ENABLE_bm;
 866:	81 e0       	ldi	r24, 0x01	; 1
 868:	80 83       	st	Z, r24
init_TCA0():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:680

void __attribute__((weak)) init_TCA0() {
  /*  TYPE A TIMER   */
  #if !defined(TCA_BUFFERED_3PIN)
    #if defined(PORTMUX_CTRLC)
      PORTMUX.CTRLC = TCA_PORTMUX;
 86a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <vtable for TwoWire+0x7f754c>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:684
    #else
      PORTMUX.TCAROUTEA = TCA_PORTMUX;
    #endif
    TCA0.SPLIT.CTRLD   = TCA_SPLIT_SPLITM_bm;
 86e:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <vtable for TwoWire+0x7f7d4d>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:685
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 872:	8e ef       	ldi	r24, 0xFE	; 254
 874:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <vtable for TwoWire+0x7f7d70>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:686
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 878:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <vtable for TwoWire+0x7f7d71>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:687
    TCA0.SPLIT.CTRLA   = (_TIMERA_PRESCALER | TCA_SPLIT_ENABLE_bm);
 87c:	8b e0       	ldi	r24, 0x0B	; 11
 87e:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <vtable for TwoWire+0x7f7d4a>
init_millis():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring.c:339
  #if defined(MILLIS_USE_TIMERNONE)
    badCall("init_millis() is only valid with millis time keeping enabled.");
  #else
    #if defined(MILLIS_USE_TIMERA0)
      #if !defined(TCA_BUFFERED_3PIN)
        TCA0.SPLIT.INTCTRL = TCA_SPLIT_HUNF_bm;
 882:	82 e0       	ldi	r24, 0x02	; 2
 884:	80 93 0a 0a 	sts	0x0A0A, r24	; 0x800a0a <vtable for TwoWire+0x7f7d54>
main():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/main.cpp:53
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 888:	78 94       	sei
begin():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:546
    }

    void HardwareSerial::begin(unsigned long baud, uint16_t options) {
      // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
      // without first calling end()
      _poll_tx_data_empty(); // Workaround to fix compiler omitting this function, causing compile to fail.
 88a:	8b e0       	ldi	r24, 0x0B	; 11
 88c:	9f e3       	ldi	r25, 0x3F	; 63
 88e:	e2 dc       	rcall	.-1596   	; 0x254 <HardwareSerial::_poll_tx_data_empty()>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:547
      if (_state & 1) {
 890:	80 91 17 3f 	lds	r24, 0x3F17	; 0x803f17 <Serial0+0xc>
 894:	80 ff       	sbrs	r24, 0
 896:	11 c0       	rjmp	.+34     	; 0x8ba <main+0x7c>
end():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:676
      */
    }

    void HardwareSerial::end() {
      // wait for transmission of outgoing data
      flush();
 898:	8b e0       	ldi	r24, 0x0B	; 11
 89a:	9f e3       	ldi	r25, 0x3F	; 63
 89c:	44 dd       	rcall	.-1400   	; 0x326 <HardwareSerial::flush()>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:679
      // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
      // TXCIE only used in half duplex - we can just turn the damned thing off yo!
      volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
 89e:	e0 91 13 3f 	lds	r30, 0x3F13	; 0x803f13 <Serial0+0x8>
 8a2:	f0 91 14 3f 	lds	r31, 0x3F14	; 0x803f14 <Serial0+0x9>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:680
      temp -> CTRLB = 0; //~(USART_RXEN_bm | USART_TXEN_bm);
 8a6:	16 82       	std	Z+6, r1	; 0x06
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:681
      temp -> CTRLA = 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
 8a8:	15 82       	std	Z+5, r1	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:682
      temp -> STATUS =  USART_TXCIF_bm | USART_RXCIF_bm; // want to make sure no chance of that firing in error now that the USART is off. TXCIE only used in half duplex
 8aa:	80 ec       	ldi	r24, 0xC0	; 192
 8ac:	84 83       	std	Z+4, r24	; 0x04
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:684
      // clear any received data
      _rx_buffer_head = _rx_buffer_tail;
 8ae:	80 91 19 3f 	lds	r24, 0x3F19	; 0x803f19 <Serial0+0xe>
 8b2:	80 93 18 3f 	sts	0x3F18, r24	; 0x803f18 <Serial0+0xd>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:688

      // Note: Does not change output pins
      // though the datasheetsays turning the TX module off sets it to input.
      _state = 0;
 8b6:	10 92 17 3f 	sts	0x3F17, r1	; 0x803f17 <Serial0+0xc>
begin():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:586
        setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
      }
      if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
        setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
      }
      uint8_t oldSREG = SREG;
 8ba:	1f b7       	in	r17, 0x3f	; 63
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:587
      cli();
 8bc:	f8 94       	cli
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:588
      volatile USART_t* MyUSART = _hwserial_module;
 8be:	e0 91 13 3f 	lds	r30, 0x3F13	; 0x803f13 <Serial0+0x8>
 8c2:	f0 91 14 3f 	lds	r31, 0x3F14	; 0x803f14 <Serial0+0x9>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:589
      (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
 8c6:	16 82       	std	Z+6, r1	; 0x06
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:590
      (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
 8c8:	83 e0       	ldi	r24, 0x03	; 3
 8ca:	87 83       	std	Z+7, r24	; 0x07
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:591
      (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
 8cc:	86 eb       	ldi	r24, 0xB6	; 182
 8ce:	92 e0       	ldi	r25, 0x02	; 2
 8d0:	80 87       	std	Z+8, r24	; 0x08
 8d2:	91 87       	std	Z+9, r25	; 0x09
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:597
      if (ctrla & 0x20) {                       // Now we have to do a bit of work
        setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
        (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
        (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
      } else {
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
 8d4:	14 86       	std	Z+12, r1	; 0x0c
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:599
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
 8d6:	80 e8       	ldi	r24, 0x80	; 128
 8d8:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:600
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
 8da:	80 ec       	ldi	r24, 0xC0	; 192
 8dc:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:601
      _set_pins(_module_number, _pin_set, setpinmask); // set up the pin(s)
 8de:	90 91 16 3f 	lds	r25, 0x3F16	; 0x803f16 <Serial0+0xb>
 8e2:	20 91 15 3f 	lds	r18, 0x3F15	; 0x803f15 <Serial0+0xa>
 8e6:	2b 83       	std	Y+3, r18	; 0x03
_set_pins():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:614
        muxregval           &= ~(mod_nbr ? 0x0C : 0x03);
        PORTMUX.USARTROUTEA  = (muxregval) | (mux_set << (mod_nbr ? 2 : 0)); // shift muxset left if needed.

      #else
        if (mux_set) {
          PORTMUX.CTRLB       |= 0x01; // for 0/1-series this can only be zero or 1
 8e8:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <vtable for TwoWire+0x7f754b>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:613
        uint8_t muxregval    = PORTMUX.USARTROUTEA;
        muxregval           &= ~(mod_nbr ? 0x0C : 0x03);
        PORTMUX.USARTROUTEA  = (muxregval) | (mux_set << (mod_nbr ? 2 : 0)); // shift muxset left if needed.

      #else
        if (mux_set) {
 8ec:	99 23       	and	r25, r25
 8ee:	09 f4       	brne	.+2      	; 0x8f2 <main+0xb4>
 8f0:	ab c0       	rjmp	.+342    	; 0xa48 <main+0x20a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:614
          PORTMUX.CTRLB       |= 0x01; // for 0/1-series this can only be zero or 1
 8f2:	81 60       	ori	r24, 0x01	; 1
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:616
        } else {
          PORTMUX.CTRLB       &= 0xFE;
 8f4:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <vtable for TwoWire+0x7f754b>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:624
      #if MEGATINYCORE_SERIES == 2
        if (mux_set == 3) { // not connected to pins...
          return;           // so we are done!
        }
      #endif
      const uint8_t* muxrow = &(_usart_pins[mod_nbr + mux_set][0]);
 8f8:	eb 81       	ldd	r30, Y+3	; 0x03
 8fa:	e9 0f       	add	r30, r25
 8fc:	ff 27       	eor	r31, r31
 8fe:	ff 1f       	adc	r31, r31
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:626
      if ((enmask & 0x40 && !(enmask & 0x08))) {
        pinMode(muxrow[0], OUTPUT); // If and only if TX is enabled and open drain isn't should the TX interrupt be used. .
 900:	ee 0f       	add	r30, r30
 902:	ff 1f       	adc	r31, r31
 904:	ee 0f       	add	r30, r30
 906:	ff 1f       	adc	r31, r31
 908:	e6 57       	subi	r30, 0x76	; 118
 90a:	f3 47       	sbci	r31, 0x73	; 115
 90c:	ec 83       	std	Y+4, r30	; 0x04
 90e:	fd 83       	std	Y+5, r31	; 0x05
 910:	61 e0       	ldi	r22, 0x01	; 1
 912:	80 81       	ld	r24, Z
 914:	eb dd       	rcall	.-1066   	; 0x4ec <pinMode>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:633
        // TX should be INPUT_PULLUP.
        pinMode(muxrow[0], INPUT_PULLUP);
      }
      if (enmask & 0x80 && !(enmask & 0x10)) {
        // Likewise if RX is enabled, unless loopback mode is too (in which case we caught it above, it should be pulled up
        pinMode(muxrow[1], INPUT_PULLUP);
 916:	62 e0       	ldi	r22, 0x02	; 2
 918:	ec 81       	ldd	r30, Y+4	; 0x04
 91a:	fd 81       	ldd	r31, Y+5	; 0x05
 91c:	81 81       	ldd	r24, Z+1	; 0x01
 91e:	e6 dd       	rcall	.-1076   	; 0x4ec <pinMode>
begin():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:602
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
      _set_pins(_module_number, _pin_set, setpinmask); // set up the pin(s)
      SREG = oldSREG;                             // re-enable interrupts, and we're done.
 920:	1f bf       	out	0x3f, r17	; 63
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:290
  #if defined(TWI_MANDS)                            // Check if the user wants to use Master AND Slave
    if (_bools._hostEnabled == 1) {          // Slave is allowed to be enabled, don't re-enable the host though
      return;
    }
  #else                                             // Master OR Slave
    if ((_bools._hostEnabled | _bools._clientEnabled) == 1) {  //If either are enabled
 922:	80 91 49 3f 	lds	r24, 0x3F49	; 0x803f49 <Wire+0xb>
 926:	81 fd       	sbrc	r24, 1
 928:	24 c0       	rjmp	.+72     	; 0x972 <main+0x134>
 92a:	82 fd       	sbrc	r24, 2
 92c:	22 c0       	rjmp	.+68     	; 0x972 <main+0x134>
TWI0_ClearPins():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/twi_pins.c:148
          PORTA.OUTCLR = 0x06;  // if swapped it's on PA1, PA2
        } else {
          PORTB.OUTCLR = 0x03;  // else PB0, PB1
        }
      #elif defined(__AVR_ATtinyxy2__)
        PORTA.OUTCLR = 0x06;  // 8-pin parts always have it on PA1/2
 92e:	96 e0       	ldi	r25, 0x06	; 6
 930:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <vtable for TwoWire+0x7f7750>
begin():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:306
    }
  #else                                             // Only one TWI is used
    TWI0_ClearPins();                               // Only one option is possible
  #endif

  _bools._hostEnabled    = 1;
 934:	82 60       	ori	r24, 0x02	; 2
 936:	80 93 49 3f 	sts	0x3F49, r24	; 0x803f49 <Wire+0xb>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:307
  TWI_t* module = _module;
 93a:	e0 91 46 3f 	lds	r30, 0x3F46	; 0x803f46 <Wire+0x8>
 93e:	f0 91 47 3f 	lds	r31, 0x3F47	; 0x803f47 <Wire+0x9>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:308
  module->MCTRLA        = TWI_ENABLE_bm;  // Master Interrupt flags stay disabled
 942:	81 e0       	ldi	r24, 0x01	; 1
 944:	83 83       	std	Z+3, r24	; 0x03
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:309
  module->MSTATUS       = TWI_BUSSTATE_IDLE_gc;
 946:	85 83       	std	Z+5, r24	; 0x05
setClock():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:390
  } else {
    if (clock < 1000) {
      return 1;
    }
  }
  if (_bools._hostEnabled == 1) {              // Do something only if the host is enabled.
 948:	90 91 49 3f 	lds	r25, 0x3F49	; 0x803f49 <Wire+0xb>
 94c:	91 ff       	sbrs	r25, 1
 94e:	11 c0       	rjmp	.+34     	; 0x972 <main+0x134>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:379
 *@return     uint8_t
 *@retval       0 if no error occurred
 *@retval       1 if a problem occurred
 */
uint8_t TwoWire::setClock(uint32_t clock) {
  TWI_t* module = _module;
 950:	e0 91 46 3f 	lds	r30, 0x3F46	; 0x803f46 <Wire+0x8>
 954:	f0 91 47 3f 	lds	r31, 0x3F47	; 0x803f47 <Wire+0x9>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:392
      return 1;
    }
  }
  if (_bools._hostEnabled == 1) {              // Do something only if the host is enabled.
    uint8_t newBaud = MasterCalcBaud(clock);        // get the new Baud value
    uint8_t oldBaud = module->MBAUD;                // load the old Baud value
 958:	96 81       	ldd	r25, Z+6	; 0x06
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:393
    if (newBaud != oldBaud) {                       // compare both, in case the code is issuing this before every transmission.
 95a:	99 35       	cpi	r25, 0x59	; 89
 95c:	51 f0       	breq	.+20     	; 0x972 <main+0x134>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:394
      uint8_t restore = module->MCTRLA;             // Save the old Master state
 95e:	23 81       	ldd	r18, Z+3	; 0x03
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:395
      module->MCTRLA    = 0;                        // Disable Master
 960:	13 82       	std	Z+3, r1	; 0x03
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:396
      module->MBAUD     = newBaud;                  // update Baud register
 962:	99 e5       	ldi	r25, 0x59	; 89
 964:	96 83       	std	Z+6, r25	; 0x06
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:400
      if (clock > 400000) {
        module->CTRLA  |=  TWI_FMPEN_bm;            // Enable FastMode+
      } else {
        module->CTRLA  &= ~TWI_FMPEN_bm;            // Disable FastMode+
 966:	90 81       	ld	r25, Z
 968:	9d 7f       	andi	r25, 0xFD	; 253
 96a:	90 83       	st	Z, r25
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:402
      }
      module->MCTRLA    = restore;                  // restore the old register, thus enabling it again
 96c:	23 83       	std	Z+3, r18	; 0x03
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:403
      if (restore & TWI_ENABLE_bm) {                // If the TWI was enabled,
 96e:	20 fd       	sbrc	r18, 0
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:404
        module->MSTATUS   = TWI_BUSSTATE_IDLE_gc;   // Force the state machine into IDLE according to the data sheet
 970:	85 83       	std	Z+5, r24	; 0x05
setup():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:48
#define MEASUREMENT_INTERVAL 5000

void setup() {
  Serial.begin(115200);
  Wire.begin();
  pinMode(LED_PIN, OUTPUT);
 972:	61 e0       	ldi	r22, 0x01	; 1
 974:	84 e0       	ldi	r24, 0x04	; 4
 976:	ba dd       	rcall	.-1164   	; 0x4ec <pinMode>
beginTransmission():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:773
void TwoWire::beginTransmission(uint8_t address) {
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  if (_bools._hostEnabled) {
 978:	80 91 49 3f 	lds	r24, 0x3F49	; 0x803f49 <Wire+0xb>
 97c:	81 ff       	sbrs	r24, 1
 97e:	07 c0       	rjmp	.+14     	; 0x98e <main+0x150>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:775
    // set address of targeted client
    _clientAddress = address << 1;
 980:	84 ec       	ldi	r24, 0xC4	; 196
 982:	80 93 4f 3f 	sts	0x3F4F, r24	; 0x803f4f <Wire+0x11>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:776
    _bytesToReadWrite = 0;  // fill buffer from 0
 986:	10 92 50 3f 	sts	0x3F50, r1	; 0x803f50 <Wire+0x12>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:777
    _bytesReadWritten = 0;
 98a:	10 92 51 3f 	sts	0x3F51, r1	; 0x803f51 <Wire+0x13>
setup():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:52
  
  // Start SCD41 periodic measurement (command 0x21b1 from datasheet page 9)
  Wire.beginTransmission(SCD41_ADDR);
  Wire.write(0x21); 
 98e:	81 e2       	ldi	r24, 0x21	; 33
 990:	90 e0       	ldi	r25, 0x00	; 0
 992:	1d dd       	rcall	.-1478   	; 0x3ce <TwoWire::write(int) [clone .constprop.27]>
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:53
  Wire.write(0xb1);
 994:	81 eb       	ldi	r24, 0xB1	; 177
 996:	90 e0       	ldi	r25, 0x00	; 0
 998:	1a dd       	rcall	.-1484   	; 0x3ce <TwoWire::write(int) [clone .constprop.27]>
endTransmission():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:811
 *           20 for likely a slave holding the clock low
 *          255 (-1) for TWI not initialized (begin not called) or bus somehow in "unknown" state.
 */
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit (blocking)
  return masterTransmit(&_bytesToReadWrite, _hostBuffer, _clientAddress, sendStop);
 99a:	21 e0       	ldi	r18, 0x01	; 1
 99c:	40 91 4f 3f 	lds	r20, 0x3F4F	; 0x803f4f <Wire+0x11>
 9a0:	63 e5       	ldi	r22, 0x53	; 83
 9a2:	7f e3       	ldi	r23, 0x3F	; 63
 9a4:	80 e5       	ldi	r24, 0x50	; 80
 9a6:	9f e3       	ldi	r25, 0x3F	; 63
 9a8:	6d db       	rcall	.-2342   	; 0x84 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]>
delay():
 9aa:	68 e8       	ldi	r22, 0x88	; 136
 9ac:	73 e1       	ldi	r23, 0x13	; 19
 9ae:	80 e0       	ldi	r24, 0x00	; 0
 9b0:	90 e0       	ldi	r25, 0x00	; 0
 9b2:	bb db       	rcall	.-2186   	; 0x12a <delay.part.0>
beginTransmission():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:775
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  if (_bools._hostEnabled) {
    // set address of targeted client
    _clientAddress = address << 1;
 9b4:	84 ec       	ldi	r24, 0xC4	; 196
 9b6:	f8 2e       	mov	r15, r24
masterReceive():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:698
          #endif
          if (--dataToRead != 0) {
            module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
          } else {
            if (sendStop != 0) {
              module->MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
 9b8:	97 e0       	ldi	r25, 0x07	; 7
 9ba:	e9 2e       	mov	r14, r25
loop():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:93
    
    // Temperature in tenths of C: (-450 + temp_raw * 175 / 655. 35)
    // Formula: T = -45 + 175 * (temp_raw / 65535)
    // Multiply by 10 to get tenths: T*10 = -450 + 1750 * temp_raw / 65535
    // Simplified: T*10 = -450 + temp_raw * 1750 / 65535  -450 + temp_raw / 37. 45
    Serial.print((int16_t)(-450 + ((long)temp_raw * 1750L) / 65535L));
 9bc:	88 24       	eor	r8, r8
 9be:	8a 94       	dec	r8
 9c0:	98 2c       	mov	r9, r8
 9c2:	a1 2c       	mov	r10, r1
 9c4:	b1 2c       	mov	r11, r1
beginTransmission():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:773
void TwoWire::beginTransmission(uint8_t address) {
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  if (_bools._hostEnabled) {
 9c6:	80 91 49 3f 	lds	r24, 0x3F49	; 0x803f49 <Wire+0xb>
 9ca:	81 ff       	sbrs	r24, 1
 9cc:	06 c0       	rjmp	.+12     	; 0x9da <main+0x19c>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:775
    // set address of targeted client
    _clientAddress = address << 1;
 9ce:	f0 92 4f 3f 	sts	0x3F4F, r15	; 0x803f4f <Wire+0x11>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:776
    _bytesToReadWrite = 0;  // fill buffer from 0
 9d2:	10 92 50 3f 	sts	0x3F50, r1	; 0x803f50 <Wire+0x12>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:777
    _bytesReadWritten = 0;
 9d6:	10 92 51 3f 	sts	0x3F51, r1	; 0x803f51 <Wire+0x13>
loop():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:63
}

void loop() {
  // Read measurement (command 0xec05 from datasheet page 9)
  Wire.beginTransmission(SCD41_ADDR);
  Wire.write(0xec); 
 9da:	8c ee       	ldi	r24, 0xEC	; 236
 9dc:	90 e0       	ldi	r25, 0x00	; 0
 9de:	f7 dc       	rcall	.-1554   	; 0x3ce <TwoWire::write(int) [clone .constprop.27]>
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:64
  Wire. write(0x05);
 9e0:	85 e0       	ldi	r24, 0x05	; 5
 9e2:	90 e0       	ldi	r25, 0x00	; 0
 9e4:	f4 dc       	rcall	.-1560   	; 0x3ce <TwoWire::write(int) [clone .constprop.27]>
endTransmission():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:811
 *           20 for likely a slave holding the clock low
 *          255 (-1) for TWI not initialized (begin not called) or bus somehow in "unknown" state.
 */
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit (blocking)
  return masterTransmit(&_bytesToReadWrite, _hostBuffer, _clientAddress, sendStop);
 9e6:	21 e0       	ldi	r18, 0x01	; 1
 9e8:	40 91 4f 3f 	lds	r20, 0x3F4F	; 0x803f4f <Wire+0x11>
 9ec:	63 e5       	ldi	r22, 0x53	; 83
 9ee:	7f e3       	ldi	r23, 0x3F	; 63
 9f0:	80 e5       	ldi	r24, 0x50	; 80
 9f2:	9f e3       	ldi	r25, 0x3F	; 63
 9f4:	47 db       	rcall	.-2418   	; 0x84 <unsigned char TwoWire::masterTransmit<unsigned char>(unsigned char*, unsigned char*, unsigned char, unsigned char) [clone .constprop.30]>
_delay_ms():
c:\users\ewen\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino8a\avr\include\util/delay.h:187
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 9f6:	87 e8       	ldi	r24, 0x87	; 135
 9f8:	93 e1       	ldi	r25, 0x13	; 19
 9fa:	01 97       	sbiw	r24, 0x01	; 1
 9fc:	f1 f7       	brne	.-4      	; 0x9fa <main+0x1bc>
 9fe:	00 c0       	rjmp	.+0      	; 0xa00 <main+0x1c2>
 a00:	00 00       	nop
requestFrom():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:745
  }
  if (quantity >= TWI_BUFFER_LENGTH) {
    quantity = TWI_BUFFER_LENGTH;
  }

  _clientAddress = address << 1;
 a02:	f0 92 4f 3f 	sts	0x3F4F, r15	; 0x803f4f <Wire+0x11>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:746
  _bytesToReadWrite = quantity;  // for available/read/peek
 a06:	99 e0       	ldi	r25, 0x09	; 9
 a08:	90 93 50 3f 	sts	0x3F50, r25	; 0x803f50 <Wire+0x12>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:747
  _bytesReadWritten = 0;
 a0c:	10 92 51 3f 	sts	0x3F51, r1	; 0x803f51 <Wire+0x13>
masterReceive():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:637
 *@retval     error code, see masterTrasnmit
 */


uint8_t TwoWire::masterReceive(auto *length, uint8_t *buffer, uint8_t addr, uint8_t sendStop) {
  TWI_t *module = _module;
 a10:	e0 91 46 3f 	lds	r30, 0x3F46	; 0x803f46 <Wire+0x8>
 a14:	f0 91 47 3f 	lds	r31, 0x3F47	; 0x803f47 <Wire+0x9>
main():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:647

  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t state = 0;
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = (F_CPU/1000);
 a18:	80 e2       	ldi	r24, 0x20	; 32
 a1a:	9e e4       	ldi	r25, 0x4E	; 78
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:645
  TWIR_INIT_ERROR;             // local variable for errors
  auto dataToRead = *length;

  uint8_t currentSM;
  uint8_t currentStatus;
  uint8_t state = 0;
 a1c:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:641
uint8_t TwoWire::masterReceive(auto *length, uint8_t *buffer, uint8_t addr, uint8_t sendStop) {
  TWI_t *module = _module;
  __asm__ __volatile__("\n\t" : "+z"(module));

  TWIR_INIT_ERROR;             // local variable for errors
  auto dataToRead = *length;
 a1e:	29 e0       	ldi	r18, 0x09	; 9
masterReceive():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:638
 */


uint8_t TwoWire::masterReceive(auto *length, uint8_t *buffer, uint8_t addr, uint8_t sendStop) {
  TWI_t *module = _module;
  __asm__ __volatile__("\n\t" : "+z"(module));
 a20:	a3 e5       	ldi	r26, 0x53	; 83
 a22:	bf e3       	ldi	r27, 0x3F	; 63
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:651
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = (F_CPU/1000);
  #endif

  while (true) {
    currentStatus = module->MSTATUS;
 a24:	35 81       	ldd	r19, Z+5	; 0x05
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:652
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
 a26:	53 2f       	mov	r21, r19
 a28:	53 70       	andi	r21, 0x03	; 3
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:654

    if (currentSM == TWI_BUSSTATE_UNKNOWN_gc) {
 a2a:	a1 f0       	breq	.+40     	; 0xa54 <main+0x216>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:660
      TWIR_SET_ERROR(TWI_ERR_UNINIT);
      break;
    }

    #if defined(TWI_TIMEOUT_ENABLE)
      if (--timeout == 0) {
 a2c:	01 97       	sbiw	r24, 0x01	; 1
 a2e:	91 f0       	breq	.+36     	; 0xa54 <main+0x216>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:672
        }
        break;
      }
    #endif

    if (currentStatus & TWI_ARBLOST_bm) {   // Check for Bus error
 a30:	33 fd       	sbrc	r19, 3
 a32:	15 c0       	rjmp	.+42     	; 0xa5e <main+0x220>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:676
      return TWI_ERR_BUS_ARB;               // leave RX loop
    }

    if (currentSM != TWI_BUSSTATE_BUSY_gc) {
 a34:	53 30       	cpi	r21, 0x03	; 3
 a36:	b1 f3       	breq	.-20     	; 0xa24 <main+0x1e6>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:677
      if (state == 0x00) {
 a38:	41 11       	cpse	r20, r1
 a3a:	08 c0       	rjmp	.+16     	; 0xa4c <main+0x20e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:678
        module->MADDR = ADD_READ_BIT(addr);     // Send Address with read bit
 a3c:	35 ec       	ldi	r19, 0xC5	; 197
 a3e:	37 83       	std	Z+7, r19	; 0x07
main():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:681
        state |= 0x01;
        #if defined (TWI_TIMEOUT_ENABLE)
          timeout = (F_CPU/1000);               // reset timeout
 a40:	80 e2       	ldi	r24, 0x20	; 32
 a42:	9e e4       	ldi	r25, 0x4E	; 78
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:679
    }

    if (currentSM != TWI_BUSSTATE_BUSY_gc) {
      if (state == 0x00) {
        module->MADDR = ADD_READ_BIT(addr);     // Send Address with read bit
        state |= 0x01;
 a44:	41 e0       	ldi	r20, 0x01	; 1
 a46:	ee cf       	rjmp	.-36     	; 0xa24 <main+0x1e6>
_set_pins():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/UART.cpp:616

      #else
        if (mux_set) {
          PORTMUX.CTRLB       |= 0x01; // for 0/1-series this can only be zero or 1
        } else {
          PORTMUX.CTRLB       &= 0xFE;
 a48:	8e 7f       	andi	r24, 0xFE	; 254
 a4a:	54 cf       	rjmp	.-344    	; 0x8f4 <main+0xb6>
masterReceive():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:684
        #if defined (TWI_TIMEOUT_ENABLE)
          timeout = (F_CPU/1000);               // reset timeout
        #endif
      } else {
        if (currentStatus & TWI_WIF_bm) {
 a4c:	36 ff       	sbrs	r19, 6
 a4e:	af c0       	rjmp	.+350    	; 0xbae <main+0x370>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:686
          TWIR_SET_ERROR(TWI_ERR_ACK_ADR);        // set error flag
          module->MCTRLB = TWI_MCMD_STOP_gc;      // free the bus
 a50:	83 e0       	ldi	r24, 0x03	; 3
 a52:	84 83       	std	Z+4, r24	; 0x04
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:708
          }
        }
      }
    }
  }
  *length -= dataToRead;
 a54:	80 91 50 3f 	lds	r24, 0x3F50	; 0x803f50 <Wire+0x12>
 a58:	82 1b       	sub	r24, r18
 a5a:	80 93 50 3f 	sts	0x3F50, r24	; 0x803f50 <Wire+0x12>
available():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:997
    if (_bools._toggleStreamFn == 0x01) {
      return (_bytesToReadWriteS - _bytesReadWrittenS);
    }
  #endif

  return (_bytesToReadWrite - _bytesReadWritten);
 a5e:	80 91 50 3f 	lds	r24, 0x3F50	; 0x803f50 <Wire+0x12>
 a62:	90 91 51 3f 	lds	r25, 0x3F51	; 0x803f51 <Wire+0x13>
 a66:	89 1b       	sub	r24, r25
 a68:	99 0b       	sbc	r25, r25
loop():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:72
  delay(1); // Wait 1ms for command execution
  
  // Request 9 bytes: CO2(2) + CRC(1) + Temp(2) + CRC(1) + Hum(2) + CRC(1)
  Wire.requestFrom(SCD41_ADDR, 9);
  
  if (Wire.available() >= 9) {
 a6a:	09 97       	sbiw	r24, 0x09	; 9
 a6c:	0c f4       	brge	.+2      	; 0xa70 <main+0x232>
 a6e:	99 c0       	rjmp	.+306    	; 0xba2 <main+0x364>
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:74
    // Read CO2 (2 bytes + CRC)
    uint16_t co2 = Wire.read() << 8 | Wire.read();
 a70:	8e e3       	ldi	r24, 0x3E	; 62
 a72:	9f e3       	ldi	r25, 0x3F	; 63
 a74:	88 dc       	rcall	.-1776   	; 0x386 <TwoWire::read()>
 a76:	28 2e       	mov	r2, r24
 a78:	8e e3       	ldi	r24, 0x3E	; 62
 a7a:	9f e3       	ldi	r25, 0x3F	; 63
 a7c:	84 dc       	rcall	.-1784   	; 0x386 <TwoWire::read()>
 a7e:	8c 83       	std	Y+4, r24	; 0x04
 a80:	9d 83       	std	Y+5, r25	; 0x05
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:75
    Wire. read(); // Skip CRC
 a82:	8e e3       	ldi	r24, 0x3E	; 62
 a84:	9f e3       	ldi	r25, 0x3F	; 63
 a86:	7f dc       	rcall	.-1794   	; 0x386 <TwoWire::read()>
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:78
    
    // Read temperature raw value (2 bytes + CRC)
    uint16_t temp_raw = Wire.read() << 8 | Wire.read();
 a88:	8e e3       	ldi	r24, 0x3E	; 62
 a8a:	9f e3       	ldi	r25, 0x3F	; 63
 a8c:	7c dc       	rcall	.-1800   	; 0x386 <TwoWire::read()>
 a8e:	38 2e       	mov	r3, r24
 a90:	8e e3       	ldi	r24, 0x3E	; 62
 a92:	9f e3       	ldi	r25, 0x3F	; 63
 a94:	78 dc       	rcall	.-1808   	; 0x386 <TwoWire::read()>
 a96:	8c 01       	movw	r16, r24
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:79
    Wire.read(); // Skip CRC
 a98:	8e e3       	ldi	r24, 0x3E	; 62
 a9a:	9f e3       	ldi	r25, 0x3F	; 63
 a9c:	74 dc       	rcall	.-1816   	; 0x386 <TwoWire::read()>
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:82
    
    // Read humidity raw value (2 bytes + CRC)
    uint16_t hum_raw = Wire.read() << 8 | Wire.read();
 a9e:	8e e3       	ldi	r24, 0x3E	; 62
 aa0:	9f e3       	ldi	r25, 0x3F	; 63
 aa2:	71 dc       	rcall	.-1822   	; 0x386 <TwoWire::read()>
 aa4:	d8 2e       	mov	r13, r24
 aa6:	8e e3       	ldi	r24, 0x3E	; 62
 aa8:	9f e3       	ldi	r25, 0x3F	; 63
 aaa:	6d dc       	rcall	.-1830   	; 0x386 <TwoWire::read()>
 aac:	5d 2c       	mov	r5, r13
 aae:	41 2c       	mov	r4, r1
 ab0:	62 01       	movw	r12, r4
 ab2:	c8 2a       	or	r12, r24
 ab4:	d9 2a       	or	r13, r25
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:83
    Wire.read(); // Skip CRC
 ab6:	8e e3       	ldi	r24, 0x3E	; 62
 ab8:	9f e3       	ldi	r25, 0x3F	; 63
 aba:	65 dc       	rcall	.-1846   	; 0x386 <TwoWire::read()>
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:74
  // Request 9 bytes: CO2(2) + CRC(1) + Temp(2) + CRC(1) + Hum(2) + CRC(1)
  Wire.requestFrom(SCD41_ADDR, 9);
  
  if (Wire.available() >= 9) {
    // Read CO2 (2 bytes + CRC)
    uint16_t co2 = Wire.read() << 8 | Wire.read();
 abc:	61 2c       	mov	r6, r1
 abe:	ec 81       	ldd	r30, Y+4	; 0x04
 ac0:	fd 81       	ldd	r31, Y+5	; 0x05
 ac2:	e6 29       	or	r30, r6
 ac4:	f2 29       	or	r31, r2
print():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:83
size_t Print::print(int n, int base) {
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base) {
  return print((unsigned long) n, base);
 ac6:	bf 01       	movw	r22, r30
 ac8:	90 e0       	ldi	r25, 0x00	; 0
 aca:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
 acc:	4a e0       	ldi	r20, 0x0A	; 10
 ace:	a9 dc       	rcall	.-1710   	; 0x422 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]>
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/HardwareSerial.h:383
    virtual    void flush(void);
    virtual  size_t write(uint8_t ch);
    inline   size_t write(unsigned long n)  {return write((uint8_t)n);}
    inline   size_t write(long n)           {return write((uint8_t)n);}
    inline   size_t write(unsigned int n)   {return write((uint8_t)n);}
    inline   size_t write(int n)            {return write((uint8_t)n);}
 ad0:	6c e2       	ldi	r22, 0x2C	; 44
 ad2:	8b e0       	ldi	r24, 0x0B	; 11
 ad4:	9f e3       	ldi	r25, 0x3F	; 63
 ad6:	dd db       	rcall	.-2118   	; 0x292 <HardwareSerial::write(unsigned char)>
loop():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:78
    Wire. read(); // Skip CRC
    
    // Read temperature raw value (2 bytes + CRC)
    uint16_t temp_raw = Wire.read() << 8 | Wire.read();
 ad8:	3a 82       	std	Y+2, r3	; 0x02
 ada:	19 82       	std	Y+1, r1	; 0x01
 adc:	29 81       	ldd	r18, Y+1	; 0x01
 ade:	3a 81       	ldd	r19, Y+2	; 0x02
 ae0:	20 2b       	or	r18, r16
 ae2:	31 2b       	or	r19, r17
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:93
    
    // Temperature in tenths of C: (-450 + temp_raw * 175 / 655. 35)
    // Formula: T = -45 + 175 * (temp_raw / 65535)
    // Multiply by 10 to get tenths: T*10 = -450 + 1750 * temp_raw / 65535
    // Simplified: T*10 = -450 + temp_raw * 1750 / 65535  -450 + temp_raw / 37. 45
    Serial.print((int16_t)(-450 + ((long)temp_raw * 1750L) / 65535L));
 ae4:	a6 ed       	ldi	r26, 0xD6	; 214
 ae6:	b6 e0       	ldi	r27, 0x06	; 6
 ae8:	bc d0       	rcall	.+376    	; 0xc62 <__umulhisi3>
 aea:	a5 01       	movw	r20, r10
 aec:	94 01       	movw	r18, r8
 aee:	9d d0       	rcall	.+314    	; 0xc2a <__divmodsi4>
 af0:	22 5c       	subi	r18, 0xC2	; 194
 af2:	31 40       	sbci	r19, 0x01	; 1
 af4:	b9 01       	movw	r22, r18
 af6:	03 2e       	mov	r0, r19
 af8:	00 0c       	add	r0, r0
 afa:	88 0b       	sbc	r24, r24
 afc:	99 0b       	sbc	r25, r25
print():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:90

size_t Print::print(long n, int base) {
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
 afe:	37 ff       	sbrs	r19, 7
 b00:	63 c0       	rjmp	.+198    	; 0xbc8 <main+0x38a>
 b02:	d5 dc       	rcall	.-1622   	; 0x4ae <Print::print(long, int) [clone .part.3] [clone .constprop.13]>
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/HardwareSerial.h:383
 b04:	6c e2       	ldi	r22, 0x2C	; 44
 b06:	8b e0       	ldi	r24, 0x0B	; 11
 b08:	9f e3       	ldi	r25, 0x3F	; 63
 b0a:	c3 db       	rcall	.-2170   	; 0x292 <HardwareSerial::write(unsigned char)>
loop():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:98
    Serial.write(',');
    
    // Humidity in tenths of %RH: (hum_raw * 100 / 65535) * 10
    // Simplified: hum_raw * 1000 / 65535
    Serial.print((uint16_t)(((long)hum_raw * 1000L) / 65535L));
 b0c:	96 01       	movw	r18, r12
 b0e:	a8 ee       	ldi	r26, 0xE8	; 232
 b10:	b3 e0       	ldi	r27, 0x03	; 3
 b12:	a7 d0       	rcall	.+334    	; 0xc62 <__umulhisi3>
 b14:	a5 01       	movw	r20, r10
 b16:	94 01       	movw	r18, r8
 b18:	88 d0       	rcall	.+272    	; 0xc2a <__divmodsi4>
 b1a:	ca 01       	movw	r24, r20
 b1c:	b9 01       	movw	r22, r18
print():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
 b1e:	4a e0       	ldi	r20, 0x0A	; 10
 b20:	80 dc       	rcall	.-1792   	; 0x422 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]>
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/HardwareSerial.h:383
 b22:	6c e2       	ldi	r22, 0x2C	; 44
 b24:	8b e0       	ldi	r24, 0x0B	; 11
 b26:	9f e3       	ldi	r25, 0x3F	; 63
 b28:	b4 db       	rcall	.-2200   	; 0x292 <HardwareSerial::write(unsigned char)>
analogRead():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_analog.c:716
      // don't waste flash on smallest parts.
      if ((pin & 0x7F) > 0x1F) { // highest valid mux value for any 0 or 1-series part.
        return ADC_ERROR_BAD_PIN_OR_CHANNEL;
      }
    #endif
    if (!ADC0.CTRLA & 0x01) return ADC_ERROR_DISABLED;
 b2a:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <vtable for TwoWire+0x7f794a>
main():
 b2e:	69 ef       	ldi	r22, 0xF9	; 249
 b30:	72 e8       	ldi	r23, 0x82	; 130
analogRead():
 b32:	88 23       	and	r24, r24
 b34:	69 f0       	breq	.+26     	; 0xb50 <main+0x312>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_analog.c:720
    pin &= 0x1F;
    /* Reference should be already set up */
    /* Select channel */
    ADC0.MUXPOS = (pin << ADC_MUXPOS_gp);
 b36:	e0 92 06 06 	sts	0x0606, r14	; 0x800606 <vtable for TwoWire+0x7f7950>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_analog.c:727
    #if defined(STRICT_ERROR_CHECKING)
      if (ADC0.COMMAND) return ADC_ERROR_BUSY;
    #endif

    /* Start conversion */
    ADC0.COMMAND = ADC_STCONV_bm;
 b3a:	f1 e0       	ldi	r31, 0x01	; 1
 b3c:	f0 93 08 06 	sts	0x0608, r31	; 0x800608 <vtable for TwoWire+0x7f7952>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_analog.c:730

    /* Wait for result ready */
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
 b40:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <vtable for TwoWire+0x7f7955>
 b44:	80 ff       	sbrs	r24, 0
 b46:	fc cf       	rjmp	.-8      	; 0xb40 <main+0x302>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_analog.c:733

    /* Combine two bytes */
    return ADC0.RES;
 b48:	60 91 10 06 	lds	r22, 0x0610	; 0x800610 <vtable for TwoWire+0x7f795a>
 b4c:	70 91 11 06 	lds	r23, 0x0611	; 0x800611 <vtable for TwoWire+0x7f795b>
print():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:79
size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base) {
  return print((long) n, base);
 b50:	07 2e       	mov	r0, r23
 b52:	00 0c       	add	r0, r0
 b54:	88 0b       	sbc	r24, r24
 b56:	99 0b       	sbc	r25, r25
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:90

size_t Print::print(long n, int base) {
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
 b58:	97 ff       	sbrs	r25, 7
 b5a:	39 c0       	rjmp	.+114    	; 0xbce <main+0x390>
 b5c:	a8 dc       	rcall	.-1712   	; 0x4ae <Print::print(long, int) [clone .part.3] [clone .constprop.13]>
write():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.h:56
 b5e:	42 e0       	ldi	r20, 0x02	; 2
 b60:	50 e0       	ldi	r21, 0x00	; 0
 b62:	68 ec       	ldi	r22, 0xC8	; 200
 b64:	7c e8       	ldi	r23, 0x8C	; 140
 b66:	8b e0       	ldi	r24, 0x0B	; 11
 b68:	9f e3       	ldi	r25, 0x3F	; 63
 b6a:	0b db       	rcall	.-2538   	; 0x182 <Print::write(unsigned char const*, unsigned int)>
digitalRead():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:363

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
 b6c:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <vtable for TwoWire+0x7f7752>
 b70:	83 fd       	sbrc	r24, 3
 b72:	30 c0       	rjmp	.+96     	; 0xbd4 <main+0x396>
digitalWrite():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:276
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 b74:	28 e0       	ldi	r18, 0x08	; 8
 b76:	20 93 05 04 	sts	0x0405, r18	; 0x800405 <vtable for TwoWire+0x7f774f>
loop():
C:\Users\Ewen\Documents\Projets\VAN\code\Van\HTCO2\ATtiny402_HTCO2/ATtiny402_HTCO2.ino:105
    
    // Light sensor raw ADC value (0-1023)
    Serial.println(analogRead(PHOTORESISTOR_PIN));
    
    // Toggle LED to indicate successful reading
    digitalWrite(LED_PIN, !digitalRead(LED_PIN));
 b7a:	81 e0       	ldi	r24, 0x01	; 1
digitalWrite():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:280
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 b7c:	90 91 00 04 	lds	r25, 0x0400	; 0x800400 <vtable for TwoWire+0x7f774a>
 b80:	93 fd       	sbrc	r25, 3
 b82:	0a c0       	rjmp	.+20     	; 0xb98 <main+0x35a>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:287
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 b84:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:288
    cli();
 b86:	f8 94       	cli
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:290

    if (val == LOW) {
 b88:	81 11       	cpse	r24, r1
 b8a:	29 c0       	rjmp	.+82     	; 0xbde <main+0x3a0>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:292
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 b8c:	80 91 13 04 	lds	r24, 0x0413	; 0x800413 <vtable for TwoWire+0x7f775d>
 b90:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:295
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 b92:	80 93 13 04 	sts	0x0413, r24	; 0x800413 <vtable for TwoWire+0x7f775d>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:299
    }

    /* Restore system status */
    SREG = status;
 b96:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:142
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
          }
        #endif // End if 8 vs normal parts
        TCA0.SPLIT.CTRLB &= ~bit_mask;
 b98:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <vtable for TwoWire+0x7f7d4b>
 b9c:	8f 7e       	andi	r24, 0xEF	; 239
 b9e:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <vtable for TwoWire+0x7f7d4b>
delay():
 ba2:	68 e8       	ldi	r22, 0x88	; 136
 ba4:	73 e1       	ldi	r23, 0x13	; 19
 ba6:	80 e0       	ldi	r24, 0x00	; 0
 ba8:	90 e0       	ldi	r25, 0x00	; 0
 baa:	bf da       	rcall	.-2690   	; 0x12a <delay.part.0>
 bac:	0c cf       	rjmp	.-488    	; 0x9c6 <main+0x188>
masterReceive():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:688
      } else {
        if (currentStatus & TWI_WIF_bm) {
          TWIR_SET_ERROR(TWI_ERR_ACK_ADR);        // set error flag
          module->MCTRLB = TWI_MCMD_STOP_gc;      // free the bus
          break;
        } else if (currentStatus & TWI_RIF_bm) {
 bae:	37 ff       	sbrs	r19, 7
 bb0:	39 cf       	rjmp	.-398    	; 0xa24 <main+0x1e6>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:689
          *buffer = module->MDATA;
 bb2:	80 85       	ldd	r24, Z+8	; 0x08
 bb4:	8d 93       	st	X+, r24
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:694
          buffer++;
          #if defined (TWI_TIMEOUT_ENABLE)
            timeout = (F_CPU/1000);                // reset timeout
          #endif
          if (--dataToRead != 0) {
 bb6:	21 50       	subi	r18, 0x01	; 1
 bb8:	29 f0       	breq	.+10     	; 0xbc4 <main+0x386>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:695
            module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
 bba:	92 e0       	ldi	r25, 0x02	; 2
 bbc:	94 83       	std	Z+4, r25	; 0x04
main():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:692
          break;
        } else if (currentStatus & TWI_RIF_bm) {
          *buffer = module->MDATA;
          buffer++;
          #if defined (TWI_TIMEOUT_ENABLE)
            timeout = (F_CPU/1000);                // reset timeout
 bbe:	80 e2       	ldi	r24, 0x20	; 32
 bc0:	9e e4       	ldi	r25, 0x4E	; 78
 bc2:	30 cf       	rjmp	.-416    	; 0xa24 <main+0x1e6>
masterReceive():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\libraries\Wire\src/Wire.cpp:698
          #endif
          if (--dataToRead != 0) {
            module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
          } else {
            if (sendStop != 0) {
              module->MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
 bc4:	e4 82       	std	Z+4, r14	; 0x04
 bc6:	46 cf       	rjmp	.-372    	; 0xa54 <main+0x216>
print():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore\api/Print.cpp:95
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
 bc8:	4a e0       	ldi	r20, 0x0A	; 10
 bca:	2b dc       	rcall	.-1962   	; 0x422 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]>
 bcc:	9b cf       	rjmp	.-202    	; 0xb04 <main+0x2c6>
 bce:	4a e0       	ldi	r20, 0x0A	; 10
 bd0:	28 dc       	rcall	.-1968   	; 0x422 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.15]>
 bd2:	c5 cf       	rjmp	.-118    	; 0xb5e <main+0x320>
digitalWrite():
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:256
  /* Set output to value
  This runs regardless of whether the pin is an output,
  allowing the pin to be staged with
  changed to an output. Code in the wild relies on this behavior. */
  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
 bd4:	38 e0       	ldi	r19, 0x08	; 8
 bd6:	30 93 06 04 	sts	0x0406, r19	; 0x800406 <vtable for TwoWire+0x7f7750>
 bda:	80 e0       	ldi	r24, 0x00	; 0
 bdc:	cf cf       	rjmp	.-98     	; 0xb7c <main+0x33e>
C:\Users\Ewen\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.12\cores\megatinycore/wiring_digital.c:295
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 bde:	80 91 13 04 	lds	r24, 0x0413	; 0x800413 <vtable for TwoWire+0x7f775d>
 be2:	88 60       	ori	r24, 0x08	; 8
 be4:	d6 cf       	rjmp	.-84     	; 0xb92 <main+0x354>

00000be6 <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
 be6:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
 be8:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
 bea:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
 bec:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
 bee:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
 bf0:	0d c0       	rjmp	.+26     	; 0xc0c <__udivmodsi4_ep>

00000bf2 <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
 bf2:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
 bf4:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
 bf6:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
 bf8:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
 bfa:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
 bfc:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
 bfe:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
 c00:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
 c02:	20 f0       	brcs	.+8      	; 0xc0c <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
 c04:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
 c06:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
 c08:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
 c0a:	f5 0b       	sbc	r31, r21

00000c0c <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
 c0c:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
 c0e:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
 c10:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
 c12:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
 c14:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
 c16:	69 f7       	brne	.-38     	; 0xbf2 <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
 c18:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
 c1a:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
 c1c:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
 c1e:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
 c20:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
 c22:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
 c24:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
 c26:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
 c28:	08 95       	ret

00000c2a <__divmodsi4>:
__divmodsi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
 c2a:	05 2e       	mov	r0, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
 c2c:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
 c2e:	16 f4       	brtc	.+4      	; 0xc34 <__divmodsi4+0xa>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
 c30:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
 c32:	0f d0       	rcall	.+30     	; 0xc52 <__negsi2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
 c34:	57 fd       	sbrc	r21, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1693
 c36:	05 d0       	rcall	.+10     	; 0xc42 <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
 c38:	d6 df       	rcall	.-84     	; 0xbe6 <__udivmodsi4>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
 c3a:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1696
 c3c:	02 d0       	rcall	.+4      	; 0xc42 <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
 c3e:	46 f4       	brtc	.+16     	; 0xc50 <__divmodsi4_exit>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
 c40:	08 c0       	rjmp	.+16     	; 0xc52 <__negsi2>

00000c42 <__divmodsi4_neg2>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
 c42:	50 95       	com	r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
 c44:	40 95       	com	r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
 c46:	30 95       	com	r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
 c48:	21 95       	neg	r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
 c4a:	3f 4f       	sbci	r19, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
 c4c:	4f 4f       	sbci	r20, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
 c4e:	5f 4f       	sbci	r21, 0xFF	; 255

00000c50 <__divmodsi4_exit>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
 c50:	08 95       	ret

00000c52 <__negsi2>:
__negsi2():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
 c52:	90 95       	com	r25
 c54:	80 95       	com	r24
 c56:	70 95       	com	r23
 c58:	61 95       	neg	r22
 c5a:	7f 4f       	sbci	r23, 0xFF	; 255
 c5c:	8f 4f       	sbci	r24, 0xFF	; 255
 c5e:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
 c60:	08 95       	ret

00000c62 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 c62:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 c64:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 c66:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 c68:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 c6a:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:578
 c6c:	01 d0       	rcall	.+2      	; 0xc70 <__umulhisi3+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 c6e:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 c70:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 c72:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 c74:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 c76:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 c78:	08 95       	ret

00000c7a <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 c7a:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 c7c:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 c7e:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 c80:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 c82:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 c84:	09 94       	ijmp

00000c86 <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 c86:	f8 94       	cli

00000c88 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 c88:	ff cf       	rjmp	.-2      	; 0xc88 <__stop_program>
